# 双写一致性

双写一致性，指的是写数据库和写缓存，要保证数据一致性。

一致性的分类有三种，分别是强一致性、弱一致性和最终一致性。

- 强一致性。要求数据时时一致。这种是理想目标，但实际情况很难实现，一味追求这个目标会严重降低系统的整体性能。
- 弱一致性。不要求时时一致，中间可以有一定的时间差。
- 最终一致性。数据保持一致可能需要更多的时间差，但是保证数据最终会达到一致。这种是大多数系统能接受的方案。

没有十全十美的系统，尤其是分布式系统，一致性并不是唯一追求的的目标。需要结合具体业务场景，在一致性、高可用性、分区容忍性之间做出取舍。



## CAP 理论

CAP 理论指的就是一致性（Consistency）、高可用性（Avaliability）、分区容忍性（Partition tolerance）。其中分区容忍性指的是分布式系统中任何一个分区如果因为故障脱离了整体，仍然可以独立运行。这个理论用来指导分布式系统的设计，旨在说明分布式系统在设计时要权衡三个指标，不能一味追求任何一个或者想要全部要。

在实际分布式系统的设计应用中，一般优先选择要满足分区容忍性和高可用性。在这个基础上尽可能实现数据的一致性。

Redis 作为 MySQL 的缓存使用，主要有三种使用方式。其中使用最多的是旁路模式。

## 旁路模式 Cache-Aside

这种模式中 MySQL 是存储数据的核心，Redis 只用来缓存热点数据。

#### 读数据

先读 Redis 缓存，如果有数据则直接返回；如果没有缓存数据，到数据库中查数据；查到数据后把数据缓存一份到 Redis 中，以便下次查询使用。

#### 写数据

**先写数据库，然后删除缓存中的数据**。



#### 优缺点

- 优点是 Redis 仅缓存经常使用的数据，不浪费内存空间。并且简单实用。
- 缺点是初次请求需要打到数据库。不过可以提前预热热点数据。



## 读写穿透模式 Read/Write Through

#### 读数据

读数据的流程和旁路模式中的读模式原理完全相同。不同的是把控制流程从应用程序中抽离出来，抽象出一个 Cache Provider 层用来控制读数据。

Read Through 实现了关注点分离原则。应用程序之和缓存交互，由缓存组件来管理自身和数据库之间的数据同步细节。

#### 写数据

写数据也由 Cache Provider 层来负责。其内部是先写 Redis，再写数据库。



#### 优缺点

- 优点是缓存中数据永远都是最新的。
- 缺点是缓存了全部数据，成本高。先写缓存再写数据库，带来了额外延迟。





## 异步缓存写 Write behind

该模式和 Write Through 相同的是逻辑操作由 Cache Provider 操作。

不同点在于，异步缓存写是写完缓存后立即返回，然后异步的方式写数据库。

#### 优缺点

- 优点是写速度快。适用于高频写大量写的场景。
- 缺点是缓存与数据库中数据一致性不强。





## 旁路模式写数据细节

旁路模式下，写数据时会遇到很多细节问题。

- 写数据库之后，是更新缓存还是删除缓存？
- 写数据时，先写数据库，还是先操作缓存？
- 缓存删除失败怎么办？



#### 写数据库再删除缓存

旁路模式写数据时，要先写数据库，再删除缓存。不要使用更新缓存。

因为高并发场景下，同时有两个写请求。因为每个请求都要两步，先操作数据库的请求可能会后操作缓存。这种情况下，采用更新缓存的方式就会缓存了旧数据，而删除缓存的方式就不会。所以选择删除缓存更合适。



#### 先写数据库再删除缓存

旁路写的过程分为两步，这两步顺序不同，效果也可能不一样。

- 方式1：先写数据库，再删除缓存。
- 方式2：先删除缓存，再写数据库。

高并发场景下，同时一个写请求和一个读请求。

如果采用方式2，先删除了缓存，写数据库之前，读请求更新了缓存，最后再写数据库。这种场景就会让 Redis 缓存了旧数据。而方式1 不会出现这个问题。



#### 缓存延时双删

先写数据库，再删除缓存也可能出现缓存旧数据。

高并发场景下，同时两个请求，一个写一个读，并且缓存中没有数据。此时读请求先读缓存发现没有数据则到数据库读旧数据，读完后，写请求把数据库更新了然后删除缓存。此时读请求再更新缓存。这就造成缓存了旧数据。

大多数时候，都是读快于写，所以上述场景出现的概率很很低很低。

但是如果发生了这种场景，使用缓存延时双删可以解决。具体操作是写请求写数据库之后删除缓存，然后一个延迟任务等待一段时间之后再删除一次缓存。

另外，如果非要选择先删除缓存，后写数据库的方式。这种场景下使用缓存延时双删也是非常保险的做法。

延时双删中，延迟时间间隔的选择非常重要，一般建议选择一个完整读请求的耗时 + 几百毫秒。目的是保证一个读请求完全结束，写请求再延迟删除缓存中的旧数据。



#### 缓存删除失败的解决方法

先更新数据库，再删除缓存。如果删除缓存失败。则要做弥补方案。主要有两种方案。

方案1：代码中捕获删除失败的异常，把删除失败的 KEY 放到队列中。异步任务从队列中获取 KEY，然后尝试删除缓存。

方案2：使用第三方服务。比如 Canal，基于 binlog 的方式异步删除缓存。

方案1是的代码复杂度高，不如方案二。

>扩展：Canal 是一个用于 MySQL 数据增量订阅和消费的开源组件，支持多种数据订阅方式，包括基于 GTID 位点的订阅。