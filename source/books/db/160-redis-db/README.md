# Redis 数据持久化

Redis 当缓存使用时一般无需数据持久化的支持。

**把 Redis 当数据库使用时需要数据持久化功能**，避免内存数据丢失，导致服务不可用。

Rdis 数据持久化有两种方案。一种是 RDB，另一种是 AOF。



## RDB 持久化

RDB（Redis DataBase）是 Redis 两种持久化方式之一，它通过在**特定时间点**生成数据集的**快照**来实现持久化。默认把数据保存在一个名为 `dump.rdb` 的文件中，Redis 服务器重启时会加载这个文件中的数据恢复到内存中。



#### RDB 持久化的三种方式

方式1：手动触发，使用命令 `save`，把当前内存中的数据快照，然后刷到硬盘上。因为Redis 是单线程读写数据，刷盘时会阻塞其他客户端读写数据。

方式2：手动触发，使用命令 `bgsave`，fork 出来一个子进程，此时此刻，子进程的内存数据和父进程是一样的。然后子进程负责把其内存中的数据刷盘保存。这样操作相对 `SAVE` 会好点，但如果数据量大，fork 子进程也会耗时阻塞其他客户端读写。

 方式3：自动触发，配置文件中配置触发策略。你可以设置“在 N 秒内，如果至少有 M 个键发生变化，则自动触发 BGSAVE”。

**注意：下面的配置复制到配置文件时需要把后面的注释删掉**

~~~ini
save 900 1    # 在900秒（15分钟）内，如果至少有1个key发生变化
save 300 10   # 在300秒（5分钟）内，如果至少有10个key发生变化
save 60 10000 # 在60秒内，如果至少有10000个key发生变化
~~~

只要满足其中任意一个条件，Redis 就会自动触发 `BGSAVE` 来创建 RDB 快照。

你可以配置多条策略，也可以完全禁用自动保存（`save ""`）。



#### 配置 rdb 文件

~~~ini
# 是否压缩rdb文件
rdbcompression yes
 
# rdb文件的名称
dbfilename redis-6379.rdb
 
# rdb文件保存目录,该目录必须存在否则启动报错
dir /bak/redis/
~~~



## AOF 持久化

AOF 是 Append Only File 的缩写。与 RDB（在特定时间点生成数据快照）不同，AOF 持久化是通过**记录每一个写操作命令**，并将其追加到一个日志文件的末尾来实现的。

当 Redis 重启时，它会重新执行 AOF 文件中的所有命令，从而在内存中重建整个数据集。



#### 开启 AOF

默认 Redis 不开启 AOF，可以在配置文件（redis.cnf）中开启它并做策略配置。

~~~ini
# 开启aof机制
appendonly yes
 
# aof文件名
appendfilename "appendonly.aof"
 
# 保存目录,目录必须存在
dir /bak/redis/

# 写入策略,always表示每个写操作都保存到aof文件中
appendfsync always
 
# 在重写 aof 日志时是否不要刷盘
# 配置no 表示重写时刷盘优先
no-appendfsync-on-rewrite no
 
# 触发自动 AOF 重写的条件
# 当当前 AOF 文件大小比上一次重写后的大小增大了一倍（100%），并且文件体积大于 64mb 时，触发重写。
auto-aof-rewrite-percentage 100
auto-aof-rewrite-min-size 64mb

# 加载 AOF 文件时，如果文件末尾被截断，是否仍然启动
aof-load-truncated yes
~~~



#### AOF 三种写入磁盘策略

这是 AOF 最关键的配置，它是性能和数据安全性的平衡点。

- **appendfsync always**
  - **描述**：每个写命令都会执行一次 `fsync` 操作，将数据强制从内核缓存刷到磁盘。
  - **优点**：**数据最安全**，最多只会丢失一个事件循环中的命令（通常极短）。
  - **缺点**：**性能最差**。因为每个命令都要等待磁盘 I/O 完成。写入吞吐量会大幅下降。
  - **适用场景**：对数据一致性要求极高，且可以接受性能损失的场景。
- **appendfsync everysec**
  - **描述**：每秒执行一次 `fsync` 操作。这是**默认的推荐策略**。
  - **优点**：在**性能**和**数据安全**之间取得了很好的平衡。理论上最多丢失 1 秒钟的数据。
  - **缺点**：在系统异常宕机时，仍然可能丢失最后一秒钟的写命令。
  - **适用场景**：绝大多数场景，是生产环境的标配。
- **appendfsync no**
  - **描述**：由操作系统来决定何时进行同步，通常间隔 30 秒左右。
  - **优点**：**性能最快**，因为 Redis 完全不关心数据何时落盘。
  - **缺点**：**数据最不安全**。如果服务器宕机，可能会丢失大量未同步的数据。
  - **适用场景**：适用于可以容忍大量数据丢失的应用，例如用于缓存且数据可以从源头重建。





#### AOF 重写

为什么需要重写？

- **文件膨胀**：例如，对一个计数器执行 100 次 `INCR`，AOF 会记录 100 条命令，但实际上只需要一条 `SET` 命令就能恢复最终状态。
- **恢复速度变慢**：文件越大，Redis 重启时重建数据的时间就越长。

重写过程是怎样的？

1. Redis 会 `fork` 出一个子进程来进行重写工作，不会阻塞主进程处理客户端请求。
2. 子进程遍历当前数据库中的所有数据，根据数据的当前状态，生成对应的 Redis 命令。
3. 与此同时，主进程处理的新的写命令会被同时记录到现有的 AOF 缓冲区（照常写入旧 AOF 文件）和 **AOF 重写缓冲区**。
4. 当子进程完成新 AOF 文件的创建后，它会向主进程发送信号。
5. 主进程将 **AOF 重写缓冲区** 中的所有命令追加到新的 AOF 文件中。
6. 最后，主进程用新的 AOF 文件**原子性地替换**旧的 AOF 文件。之后的所有新命令都会开始追加到新的 AOF 文件中。

这个过程是安全的，即使重写失败，旧的 AOF 文件依然完好无损。

如何重写？

手动触发命令 `BGREWRITEAOF`，让服务器异步重写 AOF。





#### AOF 重写与 AOF 记录日志冲突

AOF 重写和主进程记录 AOF 日志都需要刷数据到硬盘。此时冲突了就可能导致主进程的阻塞。这个问题需要使用配置参数 `no-appendfsync-on-rewrite` 来决策。这个参数的含义是从写 aof 时要不要停止 aof 记录日志的刷盘行文。

参数值为 `no` 表示允许刷盘，此时最安全，但是效率会降低。

参数值为 `yes` 表示不刷盘直接写到内存，优先从写。这样配置的效率最高，但是增加了丢失数据的风险概率。



#### AOF 文件修复

在写 AOF 文件日志时，如果Redis 宕机，可能会造成 aof 文件格式错误。重启 Redis 时无法读取 AOF 文件。可以尝试修复 AOF 文件。

Redis 自带了一个官方的 AOF 文件修复工具，名为 `redis-check-aof`。

它的基本修复原理是：**从头到尾扫描 AOF 文件，寻找格式完整、正确的 Redis 命令，一旦发现某条命令不完整或格式错误，就截断文件到此位置，丢弃后面所有的不完整数据。**

**重要提示：**

- **修复意味着数据丢失！** 修复工具会丢弃第一个错误点之后的所有命令。你可能会丢失一部分数据。
- **务必先备份！** 在执行任何修复操作之前，**一定要先复制一份 AOF 文件作为备份**。



先备份

~~~bash
cp /bak/redis /bak/redis-bak
~~~

修复 aof 日志文件 `redis-check-aof --fix /aof/file/path`

~~~bash
redis-check-aof --fix /bak/redis/appendonlydir/appendonly.aof.4.incr.aof 
Start checking Old-Style AOF
AOF analyzed: filename=/bak/redis/appendonlydir/appendonly.aof.4.incr.aof, size=1058, ok_up_to=1058, ok_up_to_line=231, diff=0
AOF /bak/redis/appendonlydir/appendonly.aof.4.incr.aof is valid
~~~

修复后，重启 redis 服务器 ，尝试恢复数据



## AOF 与 RDB 的对比与选择

| 特性       | RDB                              | AOF                                |
| :--------- | :------------------------------- | :--------------------------------- |
| 持久化方式 | 定时生成数据快照                 | 记录每一次写命令                   |
| 数据安全   | 可能丢失最后一次快照后的所有数据 | 根据策略，丢失数据极少或完全不丢失 |
| 文件大小   | 小（二进制压缩）                 | 大（文本格式，可通过重写压缩）     |
| 恢复速度   | **快**（直接加载到内存）         | **慢**（需要逐条执行命令）         |
| 对性能影响 | `fork` 子进程时内存和 CPU 开销大 | 写入和同步的 I/O 开销大            |
| 灾难恢复   | 不好，可能丢失大量数据           | 好，可以轻松修复文件末尾错误       |



#### 生产环境建议

**通常，建议同时开启两种持久化方式**：

```bash
# 在 redis.conf 中
# RDB 规则：900秒内至少1个key变化
# 300秒内至少10个key变化
# 60秒内至少10000个key变化
save 900 1      
save 300 10     
save 60 10000   

# 开启 AOF
# 使用每秒同步
appendonly yes  
appendfsync everysec 
```

这样做可以兼得两者的优点：

- **RDB 用于灾难恢复**：RDB 文件小，恢复快，适合做冷备份和全量复制。
- **AOF 用于保证数据安全**：确保在两次 RDB 快照之间发生故障时，数据丢失最小化。

在 Redis 重启时，如果同时存在 RDB 和 AOF 文件，**Redis 会优先使用 AOF 文件来恢复数据**，因为 AOF 通常能保证数据更完整。