# 事务和锁



## 事务

事务（Transaction）是数据库操作的一个基本单元，它由一个或多个 SQL 语句组成。事务的核心思想是：**这些 SQL 语句要么全部成功执行，要么全部不执行**。



#### 事务的四大特性

事务必须满足四个特性，简称 ACID：

| 特性            | 全称       | 解释                                                         |
| :-------------- | :--------- | :----------------------------------------------------------- |
| **A**tomicity   | **原子性** | 事务是一个不可分割的工作单位。事务中的所有操作要么都发生，要么都不发生。 |
| **C**onsistency | **一致性** | 事务执行前后，数据库必须从一个一致性状态变换到另一个一致性状态。例如转账前后，两个账户的总金额保持不变。 |
| **I**solation   | **隔离性** | 数据库允许多个并发事务同时对其数据进行读写和修改的能力。隔离性可以防止多个事务并发执行时，由于交叉执行而导致数据的不一致。 |
| **D**urability  | **持久性** | 事务一旦被提交，它对数据库中数据的改变就是永久性的，即使系统发生故障也不会丢失。 |



## MySQL 事务运行模式

MySQL 默认使用的是 `InnoDB` 存储引擎，它才支持事务。`MyISAM` 引擎不支持事务。



#### 隐式开启隐式提交（默认）

MySQL 默认开启了自动提交模式。这意味着每一条单独的 SQL 语句都会被当作一个事务，并自动提交。

查看当前自动提交状态

~~~sql
SHOW VARIABLES LIKE 'autocommit'; 	-- 通常是 ON
~~~



#### 隐式开启显式提交

这种模式无需手动开启事务，执行一条 SQL 语句机会自动开启事务。然后需要手动使用提交事务。手动使用 `commit;` 或者 `rollback;` 结束事务。

想要使用这种模式，需要关闭自动提交。

临时关闭自动提交

~~~sql
SET autocommit = 0;
-- 开启自动提交
SET autocommit = 1;
~~~

永久关闭

~~~bash
# /etc/my.cnf
[mysqld]
autocommit=0
~~~



#### 显式开启显式提交

手动使用 `begin;` 或者 `start transaction;` 开启事务。然后执行 SQL 语句，直到使用 `commit;` 或折`rollback;` 结束事务。

手动开启的事务，默认不会自动提交。



## 事务保存点

在一个大事务中，你可以设置保存点，以便回滚到事务内的特定点，而不是回滚整个事务。

```sql
START TRANSACTION;

UPDATE account SET balance = balance - 100 WHERE id = 1;
SAVEPOINT point_a; -- 设置一个保存点 point_a

UPDATE account SET balance = balance + 100 WHERE id = 2;
-- 假设这里发生了某种错误，但我们只想回滚到 point_a
ROLLBACK TO SAVEPOINT point_a;

-- 此时，第二个 UPDATE 被撤销，第一个 UPDATE 仍然有效
-- 可以继续执行其他操作，然后提交或回滚整个事务
COMMIT;
```



## 事务中的 undo 和 redo

**事务四大特性中的一致性和持久性由事务中的 undo 日志和 redo 日志保证。**



#### Undo log

undo log 用于回滚操作。在修改语句修改 buffer pool 中的数据前，把旧值保存在 undo log 中。当事务错误执行回滚操作时使用 undo log 来恢复旧值。

undolog分两种类型，分别是 insert undo log 和 update undo log。

- insert undo log 是插入数据时产生的。因为插入行为只对本事务可见，对其他事务不可见。故在事务提交后可以直接删除。但是清理并不是在事务提交的“瞬间”同步进行的，而是通过一个异步的清理线程。
- Update undo log 是 update 和 delete 操作产生的。该 undo log 可能想要提供 MVCC 机制，因此不能在事务提交时就删除。



#### Redo log

Redo log 记录的是修改后的新值。在事务 commit 前未把数据刷到硬盘，如果遇到宕机，MySQL 会使用 bin log 和 redo log 完成故障修复。

这其中会发生两阶段提交，目的就是为了保证数据安全。让 bin log 种记录的修改行为和 redo log 中记录的修改值相匹配。可以使用参数 `innodb_flush_log_at_trx_commit` 控制 redo log 的刷盘策略。使用参数 `sync_binlog` 控制 bin log 的刷盘策略。默认推荐这两个值都为 1。



## 读现象

在高并发场景下，多个事务并发执行时，如果没有任何处理机制，大概率会出现不合理的读现象。这些现象包括：脏读、不可重复读、幻读。

MySQL 准备了多种锁机制和隔离级别来避免上述读现象的发生。

#### 脏读

一个事务读到了另一个未提交事务修改的数据。如果那个事务回滚了，那么读到的数据就是“脏”的、无效的。

#### 不可重复读

在同一个事务中，多次读取同一数据，得到的结果不同。这是因为在读取间隙，该数据被另一个已提交事务修改了。

#### 幻读

幻读是不可重复读的一个特殊场景。具体指的是范围读数据时，范围内出现了其他事务更新或插入的数据。



## 事务的隔离级别

MySQL 的四种隔离级别（从宽松到严格）

| 隔离级别                        | 脏读   | 不可重复读 | 幻读   | 备注                                                         |
| :------------------------------ | :----- | :--------- | :----- | :----------------------------------------------------------- |
| READ UNCOMMITTED（读未提交 RU） | ❌ 可能 | ❌ 可能     | ❌ 可能 | 性能最好，但问题最多，很少使用。                             |
| READ COMMITTED（读已提交 RC）   | ✅ 避免 | ❌ 可能     | ❌ 可能 | 只能读取已提交的数据。Oracle、SQL Server 默认级别。          |
| REPEATABLE READ（可重复读 RR）  | ✅ 避免 | ✅ 避免     | ❌ 可能 | **MySQL InnoDB 的默认级别**。通过 MVCC 机制在一定程度上也避免了幻读。 |
| SERIALIZABLE（串行化 S）        | ✅ 避免 | ✅ 避免     | ✅ 避免 | 通过强制事务串行执                                           |

查看和设置隔离级别

~~~sql
-- 查看当前会话的隔离级别
SELECT @@transaction_isolation;

-- 查看全局的隔离级别
SELECT @@global.transaction_isolation;

-- 设置当前会话的隔离级别
SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;

-- 设置全局的隔离级别（需要权限，重启后失效）
SET GLOBAL TRANSACTION ISOLATION LEVEL REPEATABLE READ;
~~~



## 锁

锁是为了并发时保护数据安全的一种机制，MySQL 支持复杂且强大的锁机制。

MySQL 的锁机制大致可以分为四个层次：类型、粒度、模式和使用方式。

#### 锁粒度

锁的粒度指的是锁定的数据范围大小。粒度越小，并发性越好，但锁管理开销越大；粒度越大，并发性越差，但开销越小。

**全局锁**。锁定整个数据库实例。使数据库处于只读状态。所有数据更新语句（DML）和数据结构修改语句（DDL）都会被阻塞。

加锁和解锁

~~~sql
-- 加锁
FLUSH TABLES WITH READ LOCK;
~~~

**表级锁**。锁定整张表。读锁之间不互斥，但写锁会阻塞其他所有读写操作。

~~~sql
-- 加锁
LOCK TABLES table_name READ/WRITE;
-- 解锁
UNLOCK TABLES;
~~~

**行级锁**。锁定某一行或行范围的数据。**InnoDB** 支持行级锁，这也是 InnoDB 取代 MyISAM（支持表锁） 成为默认存储引擎的关键原因之一。行锁的粒度小，并发性能高。



## InnoDB 的行级锁

InnoDB 中行锁在使用模式上可以分为两类：共享锁和互斥锁。

**共享锁的目的是为了读**。确保在读取数据时，数据不会被其他事务修改。多个事务可以同时获取同一数据行的共享锁（兼容），但不能有排他锁（互斥锁）。拿到共享锁的事务可以读数据，但写数据会被阻塞直到其他事务都释放了共享锁。

开启共享锁

~~~sql
select id, name from t1 where id=100 lock in share mode;
~~~

**互斥锁的目的是为了写。**确保在修改数据时，一个事务能进行修改。其他事务写会被阻塞，知道抢到锁的事务释放互斥锁。

`UPDATE`, `DELETE`, `INSERT` 语句会自动加互斥锁。读数据时也可以加互斥锁。

~~~sql
select id, name from t1 where id=100 for update;
~~~

<br>

#### 通过索引的方式锁数据

InnoDB 的行锁是基于索引实现的。如果一条 SQL 语句没有使用到索引，InnoDB 就不会使用行锁，而是退化为表锁。

**如果命中主键索引**。则通过主键索引树上的主键值把数据行锁住。

**如果命中辅助索引。**则先在辅助索引树上把索引值锁住，然后再拿着主键值到主键索引树上把数据行锁住。

有的时候使用索引锁住某行，但是发现相邻行可能也被锁住了。这是因为锁的算法发挥了作用。

<br>

#### 锁的算法

**记录锁**（Record Locks）。锁定索引中的一条具体记录。锁指定的索引行。

**间隙锁**（Gap Locks）。锁定一个索引**记录之间的范围**，但不包括记录本身。目的解决幻读问题。它阻止其他事务在间隙中插入新的记录。通常在 `REPEATABLE-READ` 隔离级别下，使用范围查询或查询不存在的记录时触发。

**临键锁**（Next-Key Locks）。它是 **记录锁 + 间隙锁** 的组合。锁定一个索引记录以及该记录之前的间隙。左开右闭区间，例如 `(5, 10]`。它是 InnoDB 在 `REPEATABLE-READ` 隔离级别下的默认行锁算法。

~~~sql
-- 示例：如果索引有值 10, 11, 13。执行 
SELECT * FROM t WHERE id > 11 FOR UPDATE;

-- 会锁住 13 这条记录（记录锁），以及 (11, 13) 这个间隙（间隙锁），以及 (13, +∞) 这个间隙。
-- 相当于锁定了 (11, +∞) 这个范围。
~~~





## 乐观锁和悲观锁

这是一种逻辑上的锁概念，并非数据库直接提供。



#### 悲观锁

- **思想**：认为并发操作很可能会冲突，因此在访问数据前先加锁。
- **实现**：基于 MySQL的数据库锁机制，如 `SELECT ... FOR UPDATE`。
- **适用场景**：写多读少，冲突频繁的场景。



#### 乐观锁

- **思想**：认为并发冲突的概率很低，只在提交更新时检查数据是否被其他事务修改过。
- **实现**：**不使用数据库锁**，通常通过**版本号**或**时间戳**实现。
    - 在数据表中增加一个 `version` 字段。
    - 读取数据时，同时读出 `version`。
    - 更新数据时，执行 `UPDATE table SET name='new_name', version=version+1 WHERE id=1 AND version=old_version;`
    - 如果返回影响行数为 0，说明 version 已被其他事务修改，本次更新失败，需要回滚或重试。
- **适用场景**：读多写少，冲突较少的场景。





## 死锁问题

死锁是指两个或两个以上的事务在执行过程中，因争夺锁资源而造成的一种**相互等待**的现象。若无外力干预，这些事务都将无法继续执行下去。

#### 如何分析和定位死锁

获取死锁信息，在输出结果中找到 `LATEST DETECTED DEADLOCK` 部分。

```sql
SHOW ENGINE INNODB STATUS\G
```

#### 常见的死锁场景及解决方案

场景1：多个事务以不同的顺序更新多条记录。

解决方案：**强制统一的访问顺序**：在应用层代码中，规定所有需要更新多条记录的业务逻辑，都必须按照相同的顺序（例如，按主键ID升序）来访问数据。这是最有效的方法。

场景2：在 `REPEATABLE-READ` 隔离级别下，InnoDB 为了防止幻读会使用间隙锁。两个事务可能在同一个间隙上申请互相冲突的间隙锁，导致死锁。

解决方案：如果业务允许，可以考虑将隔离级别降为 `READ-COMMITTED`，此时 Gap Lock 会被禁用（除非遇到外键约束或唯一键冲突检查）。优化索引，减少间隙锁的范围。

场景3：一个事务中包含多个 `UPDATE` 语句，即使更新的是同一张表的不同行，如果并发事务以不同顺序执行，也可能死锁。

解决方案：统一SQL语句的执行顺序。





## MVCC 多版本并发控制

MVCC 的全称是 Multi-Version Concurrency Control，即多版本并发控制。

- **核心思想**：**为数据行创建多个版本**。当要读取或修改某行数据时，系统并不直接操作当前数据，而是通过一定的规则访问到某个特定的“版本”。
- **主要目的**：为了解决数据库并发访问中**读-写**和**写-读**操作的冲突，使得**读操作不会阻塞写操作，写操作也不会阻塞读操作**，从而大幅提升并发性能。
- **实现方式**：InnoDB 通过在每行记录后面保存多个版本来实现。旧版本数据存放在 **Undo Log（回滚日志）** 中。

### 为什么需要 MVCC？—— 解决锁的瓶颈

在没有 MVCC 的情况下，为了保证事务的隔离性（如可重复读），通常的做法是使用锁：

- 事务 A 在读数据时，会加上**共享锁**。
- 此时事务 B 想写这条数据，就需要获取**排他锁**，但排他锁与共享锁不兼容，所以事务 B 必须等待事务 A 释放共享锁。
- 这就导致了 **“读阻塞写”**。

反之，如果事务 A 在写数据（持有排他锁），事务 B 想读数据（申请共享锁），也会导致 **“写阻塞读”**。

这种锁机制虽然能保证数据安全，但严重影响了并发性能。MVCC 就是为了解决这个问题而生的。



### MVCC 核心组件

隐藏字段。InnoDB 为每行数据（记录）添加了三个隐藏的系统字段。

回滚日志。主要用于事务回滚和 MVCC。

读视图。在事务执行快照读（普通 SELECT 语句）时产生的，用于决定当前事务能看到哪个版本的数据。

当一个事务执行 `SELECT` 语句时，会访问某行数据的版本链。它通过将自己的 Read View 与版本链中每个版本的 `DB_TRX_ID` 进行比较，来决定哪个版本对它来说是“可见的”。如果某个版本对当前事务不可见，就顺着回滚指针找到上一个版本，重复上述判断规则，直到找到可见的版本或版本链结束。



### MVCC 在不同隔离级别下的表现

MVCC 的行为与事务的隔离级别密切相关。

| 隔离级别 | MVCC 行为                                                    |
| :------- | :----------------------------------------------------------- |
| 读未提交 | **不使用 MVCC**。直接读取数据的最新版本，即使它未被提交，所以会读到脏数据。 |
| 读已提交 | **每次执行 SELECT 语句时，都会生成一个新的 Read View**。这导致在一个事务内，两次相同的查询可能会看到不同的数据（因为别的事务提交了），解决了脏读，但存在不可重复读。 |
| 可重复读 | **只在第一次执行 SELECT 语句时生成一个 Read View**，后续的所有读操作都会复用这个 Read View。这保证了在同一事务中，多次读取同一数据的结果是一致的，解决了不可重复读。这也是 InnoDB 在此级别下能防止幻读的重要原因之一。 |
| 串行化   | **不使用 MVCC**。通过强制事务串行执行来解决并发问题。读操作会加共享锁，退化为基于锁的并发控制。 |

