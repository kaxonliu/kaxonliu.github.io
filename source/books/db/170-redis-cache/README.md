# 缓存穿透击穿雪崩

把 Redis 当缓存使用，会遇到三个经典问题。分别是缓存穿透、击穿、雪崩。



## 缓存穿透

缓存穿透指的是恶意查询行为，比如查询的 key 根本不存在，在 Redis 中肯定没有，数据库中也没有。大量恶意攻击可能导致数据库瘫痪。

#### 解决方案1：缓存不存在的 key

把不存在的 key 缓存在 Redis 中，值为空值。这样就避免大量不存在的 key 打向数据库，进而保护数据库。

这个方案有缺点：
- （1）缓存大量无效的 key。导致 Redis 内存压力变大；导致 Redis 内存管理删掉有效的 key
- （2）缓存的 key 后面可能变成有效的 key，而 redis 中依然缓存的假空值，导致数据不一致。这个问题可以给 key 加过期时间来解决。



#### 解决方案2：布隆过滤器

布隆过滤器是一种算法，根据这个算法可以实现的工具直接拿来使用。

布隆过滤器的使用方法。把数据库中存在的数据 id 拿出来经过哈希处理存放在布隆过滤器中。把布隆过滤器挡在 Redis 的前面。应用程序收到客户端传过来的 key，先在布隆过滤器中判断 key 是否存在，如果不存在则直接返回；如果存在则往后走 Redis 查询。

虽然布隆过滤器存在自身的问题（哈希冲突），但是它满足我们判断 key 不存在的需求。

>布隆过滤器判断 key 存在，真是情况可能是不存在，因为哈希冲突；布隆过滤器判断 key 不存在，那真的就是不存在。



## 缓存击穿

缓存击穿是缓存穿透的一种特殊现象。**单个热点 key 在 Redis 中突然过期生效**，此时大量并发请求击穿 Redis，瞬间打向数据库，极有可能导致数据库瘫痪。

#### 解决方案1：热点数据不过期

这个方案简单好用，但是也存在缺点。因为数据库数据变了之后，导致数据不一致。此时虽然难以做到强一致性，但是可以做到弱一致性。比如使用中间件监听 MySQL 的 binlog，发现数据变了就立马更新缓存数据。



#### 解决方案2：分布式锁（推荐）

分布式锁不是应用程序中的锁，而是一个第三方的锁，整个集群环境中的所有应用程序共同使用的锁。

常用的分布式有有基于 Zookeeper实现的、基于 Redsi 实现的。

引用分布式锁之后，在应用程序中的处理流程就变成：

- 如果 Redis 中没有数据，就去抢分布式锁，抢到了锁的程序就去数据库查询数据，然后缓存在 Redis 中，再释放锁。
- 没有抢到锁的程序就原地等待 Redis 中的数据。

分布式锁保护了数据库，避免高并发的流量打坏数据库。这样的方案可以正常设置热点 KEY 的过期问题。





## 缓存雪崩

缓存雪崩也是缓存穿透的一种特殊现象。**特殊在大量的 key 在一瞬间同时全部过期失效**，导致大量请求瞬间穿过 Redis，打向数据库，极有可能导致数据库宕机。

或者是 Redis 挂了，或者网络抖动，Redis 无法访问，高并发请求直接打到数据库。



#### 解决方案1：设置随机过期时间

缓存 key 增加随机过期时间，极大程度可以减少缓存雪崩的出现。并且针对热点 KEY，建议预热数据。

具体实现，可以在应用程序中设置随机过期时间。也可以单独加一个服务，定期把数据库中的热点数据到同步到 Redis 中，并且设置随机过期时间。



#### 解决方案2：Redis 集群

为了防止 Redis 挂掉，可以做 Redis 集群实现高可用，经数据进行分片，同样的数据分布式的保存在不同的机器上；即使集群中的一个或多台机器宕机，也可以保证 Redis 服务可用。





## 总结

首先使用 布隆过滤器挡在 Redis 前面，避免缓存穿透。再配合使用分布式锁，防止单个热点 KEY 过期导致的缓存击穿。再配个使用 Redis Cluster 做集群，实现数据分片分布在集群中多台机器上，保证 Redis 服务高可用。

另外，使用多级缓存。第一层使用内存缓存加随机过期时间；第二层使用 Redis 缓存加随机过期时间。配合 Redis 集群实现服务高可用。