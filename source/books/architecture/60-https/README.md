# https

HTTPS 的全称是 **HyperText Transfer Protocol Secure**，即**安全超文本传输协议**。您可以把它理解为 HTTP 的安全升级版。

**简单来说：HTTPS = HTTP + SSL/TLS**

SSL/TLS 协议的作用就像是一个安全的隧道。发送方（浏览器）在发出数据前，先用 SSL/TLS 协议把数据加密并打包；接收方（服务器）收到后，再用 SSL/TLS 协议解密获取原始数据。即使数据在传输过程中被截获，攻击者看到的也只是毫无意义的密文。



## SSL/TLS

SSL（Secure Sockets Layer，安全套接层）及其继任者 TLS（Transport Layer Security，传输层安全）是用于在互联网通信中提供安全性的加密协议。它们的主要目标是确保两个应用程序之间通信的**隐私性**、**完整性**和**身份验证**。尽管我们现在主要使用的是更现代、更安全的 TLS，但“SSL”这个名称仍然被广泛使用（通常用来泛指 SSL/TLS）。例如，我们仍然常说“SSL 证书”而不是“TLS 证书”。

#### SSL/TLS 提供的三大保障

1. **加密**。防止窃听。通过对通信内容进行加密，只有预期的接收者才能解密和读取数据。即使数据被截获，攻击者看到的也只是乱码。
2. **完整性校验**。防止篡改。使用消息认证码来验证数据在传输过程中是否被意外或恶意地修改或损坏。如果数据被改动，接收方会丢弃该数据包。
3. **身份认证**。防止冒充。在建立连接的初始阶段，服务器（有时也包括客户端）会向对方证明自己的身份。这通常通过**数字证书**来实现，确与你通信的是真实的、可信的网站，而不是中间人攻击者。

#### 版本演变

- **SSL 1.0**：未发布，存在严重安全漏洞。
- **SSL 2.0**：已废弃。
- **SSL 3.0**：已废弃。
- **TLS 1.0**：已逐渐废弃。
- **TLS 1.1**：已逐渐废弃。
- **TLS 1.2**：目前最广泛支持的版本。
- **TLS 1.3**：最新版本，速度更快、更安全。它简化了握手过程，加密了更多信息，并废弃了不安全的加密算法。



## 非对称加密与对称加密

SSL/TLS 巧妙地结合了这两种加密方式的优点：

#### 非对称加密

- **原理**：使用一对密钥（公钥和私钥）。公钥可以公开分享，用于加密数据；私钥必须严格保密，用于解密用对应公钥加密的数据。反之亦然（用于签名）。
- **特点**：非常安全，但计算速度慢。
- **在 SSL/TLS 中的用途**：主要用于**握手阶段**，用于交换一个共同的秘密（如对称密钥），并验证服务器身份。**SSL 证书中就包含服务器的公钥**。

#### 对称加密

- **原理**：通信双方使用**同一个密钥**进行加密和解密。
- **特点**：计算速度快，适合加密大量数据。
- **在 SSL/TLS 中的用途**：在握手阶段成功交换密钥后，**后续所有的应用程序数据都使用这个对称密钥进行加密和解密**，以保证高效通信。



## CA 证书

CA 是一个第三方权威认证中心，服务端会把自己的公钥和相关信息发给 CA 中心，CA 中心审核通过后，使用自己的密钥加密服务端的公钥等信息，最终得到一个 CA 证书，给到服务端保存。CA 证书相当于一个加密的服务端公钥。

客户端和服务端 https 通信前，拿到服务端的 CA 证书，会向 CA 中心验证服务端的 CA 证书的合法性。如果合法，客户端使用 CA 中心的公钥解密服务端的证书，可以拿到服务端的公钥。这样做可以保证服务端公钥的合法性。





## SSL 单向通信认证流程

https 建立连接前需要握手完成认证流程，单向的认证流程如下。

1. 客户端请求，发送 ssl 版本等信息。
2. 服务端响应给客户端 ssl 版本、随机数、签名和证书。
3. 客户端向 CA 中心验证服务端证书的合法性。合法则继续（同时拿到服务端公钥），非法则告警。
4. 客户端发送自己支持的对称加密方案给服务端，供其选择。
5. 服务端选择一个最安全的加密方案，以明文的方式发送给客户端，
6. 客户端接收加密方案后，产生一个随机码，作为对称加密的密钥。使用服务端的公钥加密密码发送服务端，
7. 服务端使用私钥解密，拿到对称通信的密钥。
8. 后面就使用对称加密通信。





## SSL 双向通信认证流程

单向认证指的是 客户端验证服务端的合法性。双向再单向的基础上增加服务端验证客户端的合法性。整体流程不变，只是在验证完服务端合法之后，增加服务端验证客户端是否合法这个流程。

1. 客户端（如浏览器）向服务器的443端口发起连接请求，发送 ssl 版本等信息。
2. 服务端响应给客户端 ssl 版本、随机数、签名和证书。
3. 客户端向 CA 中心验证服务端证书的合法性。合法则继续（同时拿到服务端公钥），非法则告警。
4. 客户端认为服务端合法之后，发送自己的证书给服务端。
5. 服务端验证客户端证书后，可以拿到客户端的公钥。
6. 客户端发送自己支持的对称加密方案给服务端，供其选择。
7. 服务端选择一个最安全的加密方案，用客户端的公钥把方案加密后发给客户端。
8. 客户端使用自己的私钥解密，得到对称加密方案，产生一个随机码，作为对称加密的密钥。使用服务端的公钥加密密码发送服务端，
9. 服务端使用私钥解密，拿到对称通信的密钥。
10. 后面就使用对称加密通信。



### 数字证书类型对比总表

| 对比维度         | 域名验证 (DV)               | 组织验证 (OV)                                 | 扩展验证 (EV)                                                | 通配符证书 (*)                                               | 多域名证书 (SAN)                                             |
| :--------------- | :-------------------------- | :-------------------------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| **主要验证内容** | 只验证**域名的控制权**      | 验证域名控制权 + **企业的真实合法性**         | **最严格验证**企业合法性、物理存在性和域名权                 | 一种**功能特性**，可与DV/OV/EV结合，保护主域和所有同级子域名 | 一种**功能特性**，可与DV/OV/EV结合，**一张证书保护多个完全不同的域名** |
| **颁发速度**     | **非常快** (几分钟至几小时) | **慢** (数天至数周)                           | **最慢** (一周至数周)                                        | 与其验证级别相同 (DV/OV/EV)                                  | 与其验证级别相同 (DV/OV/EV)                                  |
| **成本**         | **低** (甚至免费)           | **中高**                                      | **高**                                                       | **较高** (比单域名证书贵)                                    | **中高** (按域名数量收费)                                    |
| **安全与信任度** | **基础加密** 信任度最低     | **标准企业级** 信任度更高                     | **最高级别** 提供最高用户信任                                | 与其验证级别相同 (DV/OV/EV)                                  | 与其验证级别相同 (DV/OV/EV)                                  |
| **典型应用场景** | 个人网站、博客、测试环境    | 企业官网、政府机构、教育平台                  | 金融机构、大型企业、知名电商                                 | 拥有大量子域名的大型网站 (如: `*.example.com`)               | 拥有多个不同域名的企业 (如: 同时保护 `example.com`, `example.net`) |
| **浏览器显示**   | 地址栏显示**锁形图标**      | 地址栏显示**锁形图标** **点击可查看公司名称** | 地址栏显示**锁形图标** **（曾直接显示绿色公司名，现需点击查看）** |                                                              |                                                              |

注意：
- https证书不支持续费，证书到期需要重新申请并进行替换
- https不支持三级域名解析，如 test.m.linux.com





## 配置 https

在平台购买证书，会得到证书 `server.crt` 和私钥 `server.key`，在 nginx 中配置即可。

新增一个 `server` 监听 `443` 端口，开启 ssl 功能。

~~~nginx
server {
    listen 443 ssl;
    server_name kaxonliu.cn 192.168.71.16;
    ssl_certificate /etc/nginx/ssl_key/server.crt;
    ssl_certificate_key /etc/nginx/ssl_key/server.key;
 
    location / {
        root /usr/share/nginx/html;
        index index.html;
    }
}
~~~

## 配置 http 自动转 https 

新增一个 `server` 监听 `80` 端口，使用 `rewrite` 重写到 https

~~~nginx
server {
    listen 443 ssl;
    server_name kaxonliu.cn 192.168.71.16;
    ssl_certificate /etc/nginx/ssl_key/server.crt;
    ssl_certificate_key /etc/nginx/ssl_key/server.key;
 
    location / {
        root /usr/share/nginx/html;
        index index.html;
    }
}

server {
    listen 80;
    server_name kaxonliu.cn 192.168.71.16;
 
    rewrite (.*) https://$server_name$1;
}
~~~



## 全站 https 

**在负载均衡机器上配置 nginx** 。因为后端服务和负载均衡是内网通信，所以简单用 http 协议就行，如果你用 https 协议那后端 web 是无法解析加密数据的，需要你在负载均衡与后端的 web 之间再做证书，就非常麻烦了，意义不是特别大，毕竟都是内网。

~~~nginx
http {
    upstream webserver {
      server 192.168.71.14:8080;
      server 192.168.71.15:8080;
    }
    server {
        listen 443 ssl;
        server_name kaxonliu.cn 192.168.71.13;
        ssl_certificate /etc/nginx/ssl_key/server.crt;
        ssl_certificate_key /etc/nginx/ssl_key/server.key;
 
        location / {
            proxy_pass  http://webserver;  # 走内网使用http
        }
    }
    server {
        listen 80;
        server_name kaxonliu.cn 192.168.71.13;
        rewrite (.*) https://$server_name$1;
    }
}
~~~



## SSL 参数优化

~~~nginx
server {
    listen 443;
    server_name kaxonliu.cn;
    ssl on;
    root /var/www/wordpress;
    index index.php index.html index.htm;
    ssl_certificate /etc/nginx/ssl_key/server.pem;
    ssl_certificate_key /etc/nginx/ssl_key/server.key;
     
    # 在建立完ssl握手后如果断开连接，在session_timeout时间内再次连接，
    # 是不需要再次获取公钥建立握手的，可以服用之前的连接
    ssl_session_cache shared:SSL:10m; 
    
    # ssl连接断开后的超时时间
    ssl_session_timeout 1440m;  
    #配置加密套接协议
    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;  
    
    #使用TLS版本协议
    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;  
    
    #nginx决定使用哪些协议与浏览器通信
    ssl_prefer_server_ciphers on;  
  
}
~~~

