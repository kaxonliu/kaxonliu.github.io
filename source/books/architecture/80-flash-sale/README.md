# 秒杀系统

秒杀系统是高并发的典型代表，它的明显特征是：系统瞬间迎来远超平时数倍甚至百倍千倍的高流量读写压力，并且很有可能是脉冲式高并发流量。

那么秒杀系统要解决的问题不仅仅是技术问题，而是一个“如何公平地、安全地、稳定地处理远超系统容量的瞬时高并发读请求和写请求”的资源分配问题。

那具体来说，为了保障秒杀活动顺利进行。平台系统要保障三个事情，或者说要解决三个问题：高性能、高可用、高一致性。

## 高性能

高性能是支撑秒杀活动的重要手段。要做到高性能，首先要详细了解业务特点，拆分细化、逐一优化提升性能。主要办法有：动静分离、冷热分离、系统优化。

总的来说，高性能要解决高频写和高频读，优化思路如下。

- 读的问题。尽量少读，读缓存，就近读。
- 写的问题。尽量少写，批量写、漏斗写、buffer 写。



#### 动静分离

从资源类型的角度分类，可以把资源分为静态资源和动态数据。

把静态资源全部放到缓存服务器、web服务器、或者 CDN 缓存。放在离用户近的位置缓存下来减少服务器压力。服务器主要负责提供 API 响应动态数据。

动静分离之后，处理静态资源的压力就从服务器上分散出去。分离之后为架构优化创造了更多的可能。比如使用 nginx 做负载均衡。使用 cdn 节点存放静态文件资源。

##### 缓存方案

秒杀场景的缓存方案重要。要兼顾三个角度。

- 缓存点离用户足够近
- 是否适合高并发下的静态文件请求
- 能否做到主动失效/更新

常用的方案有：缓存的客户端本地、缓存在服务器（redis）、CDN 节点。一般推荐使用 CDN，因为只有它可以满足上述三个条件。缓存在客户端本地虽然足够快，但是无法控制缓存资源，也无法主动更新/失效缓存。缓存在服务端也不可取，因为离用户太远，并且处于请求链路上的最后一个节点，提速的效果有效。

##### 整个数据

动静分离后，最终需要把数据汇总在一块，整个成一个完成的页面展示给用户。这里涉及到两个整合方案。

ESI（edge side includes）在 cdn 边缘节点将动态数据和静态数据整合。一般是 cdn 全站托管，要求服务器性能好，客户端体验好。

CSI （client side includes）客户端浏览器分别从 cdn 拿到静态数据，从服务器拿到动态数据，然后在客户端整合。一般是 cdn 部分托管，服务器压力小，但是客户端体验稍差。





#### 冷热分离

从访问频率高低的角度将资源分为冷和热。只关注访问多的热点。热点细分又可以分为热点操作和热点数据。

热点操作是用户的行为，比如秒杀按钮和强红包按钮。要做防抖，包括前端防抖和后端接口防抖（接口幂等）。

对于热点优化思路和动静分离一样。首先要把热点才分处理。

##### 热点操作

无法控制用户的操作行为，但是可以引导用户的操作行为，减少疯狂点击行为。

##### 热点数据

首先要找到热点数据。对于静态文件，热点可以预测。对于动态数据，可以通过产品运营测提供预估数据，然后在活动中即使观察日志、nginx 访问 URL，采用异步的方式采集热点数据。

热点数据确认后，要做到热点数据隔离。区分对待热点请求和普通请求，不要让 1 % 影响了 99%。基于以下几个层次做热点隔离：

- 业务层面隔离。提前对已知的热点做缓存预热。
- 系统层面隔离。分组部署，独立域名，入口层把请求落到不同的集群中。
- 数据层面隔离。热点数据使用单独的缓存集群或者 db 服务组。



##### 热点优化

两种优化方式：缓存和限流。

- 热点缓存时最有效的办法。
- 限流更多是一种保护机制，但是需要和业务方确认并时时观察是否触发了限流。



#### 系统优化

优化的方面很多，硬件、系统内核、程序/代码层面（降 IO，减少非避免日志、减少调用层级）。

性能优化实在一套现有基础上进行的。在优化前需要获得当前系统性能的基准值/基线，然后才能对着预期目标做优化。有如下三个指标。

- 性能基线。在性能测试中，观察合适系统性能突然下降。性能通常包括延迟、吞吐量、资源利用等监控指标。
- 成本基线。往期举办活动使用的机器成本。
- 链路基线。核心流程发生了哪些变化。

通过基线持续关注系统性能，促使系统在以下维度进行持续优化。

- 代码层面持续提升编码质量。
- 业务层面及时下掉不合理调用。
- 架构层面不断优化改进。



## 高一致性

秒杀系统的一致性问题主要是库存扣减的准确性问题。有限的商品在同一时间被多个请求同时扣减，要保证准确性。

优化思路需要在 CAP 之间做出权衡，能保证最终一致性即可。力求达到优化的目标是避免超卖、减少恶意下单。

#### 库存问题

因为秒杀行为背后存在两个操作：下单和支付。这两个动作是独立的，因此合适减库存成为了一个需要思考和取舍的点。如果下单就扣库存，那么恶意下单不支付的行为会造成正常用户无法参与活动。如果支付后扣库存，那么大量下单成功的用户会遇到无法支付的问题。

一般我们选择预扣库存的方案。即买家下单后，库存为其保留一定的支付时间。超过这段时间未支付，占用的库存数量将自动释放。释放后其他买家可以购买。这种方式缓解了前两重方案的问题。但是依然无法真正解决恶意下单的问题（比如10分钟超时后再次下单）。

没有完美的减库存方案。都需要在用户体验和活动诉求之间做出权衡，无非就是在购物过程中的不同阶段扣库存，但是每个阶段存在被恶意利用的漏洞。



#### 避免超卖

如果使用 Redis 做缓存或者做数据库，那么使用 DECR 原子操作来减库存；如果使用关系型数据库来减库存，那么减库存的 SQL 语句要确保扣减后的数量大于等于0。或者数据库中直接设置库存字段的类型为无符号整数，一旦库存为负数执行 SQL 就会报错。

或者使用乐观锁，在代码层优化。



#### 优化并发写

方案1：简单场景。直接使用 Redis 当数据库。

方案2：复杂场景使用关系型数据库。落到 DB 上的就是一条 SQL 语句。高并发下很多线程同时执行该 SQL，会竞争行锁，并发越高等待的线程就越多，TPS吞吐量就下降，RT响应时间就上升。

解决方法有两种：

- 第一种。应用层排队。通过缓存加入分布式锁，控制并发度同时也能控制数据库连接数量。
- 第二种。数据库排队。这种更好，避免应用层排队损耗性能。阿里开源的 AliSQL，它是阿里数据库团队开发的针对 innodb 层上的补丁，可以基于 db 层对单行记录做并发排队，从而实现秒杀场景下的定制优化。



#### 通用一致性技术方案

防止超卖。使用乐观锁、悲观锁、Redis 的 DECR 命令

主从一致性。使用半同步复制、binlog 刷盘策略值为1，redo 刷盘策略值为1

redis 和 mysql 双写一致性。先更新db后删缓存，延时双删、删除失败后存在中间件中重试删除直至删除成功，canel 组件同步 binlog 到 redis。



