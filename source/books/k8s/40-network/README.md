# k8s 网络

## pod 的创建流程

创建 pod 时，会先创建一个 pause 容器，并且将网络模式设置为 None。

kubelet 会调用网络插件，来为 pause容器初始化好网络。

pause 容器的网络打通之后，根据指定的业务镜像拉起业务容器。

业务容器启动之后会设置网络模式为 container 模式与 pause 容器共享网络。

~~~alert type=note
以flannel插件的vxlan网络模式为例 <br>
先为pause容器创建一个veth，一端放在pause容器内,另外一端接到网桥上（cni0）<br>
pause容器 -----> cni0网桥------> flannel.1设备------>物理网卡eth0------>外部网络
~~~



## 跨主机网络通信网络基础

### vlan

二层网络内主机通信，主机可以在不同的物理位置，通过二层交换机连接。如果主机数量多，可以把多个二层交换机使用 TRUNK 口连接，组成一个大的二层网络。

如果想把这个二层网络划分为不同的子局域网，使用 vlan 技术，具体使用 vlan id 标识子网。

vlan 模式的问题：

- 物理网络必须是二层的（限制底层网络的灵活性）
- vlan id最多4096（限制了网络的规模）				



### GRE

使用现有的三层 IP 协议当搬运工，封装自定义协议。

- 封包解包设备：br-tun 设备
- Delivery 头：ip 协议
- GRE 头： GRE id 等同于 vlan id，用于区分不同租户的局域网
- Playload：内层包，即真实要发送的包



GRE 问题：

- 每一个节点都需要维护与其他所有物理节点的隧道关系。
- 一个二层会广播到所有其他物理节点（不支持组播）

GRE 总结：在集群规模大了的情况下，GRE 效率会变得非常慢。





### vxlan

使用现有的四层 UDP 协议当搬运工，封装自定义协议。

- 封包解包设备：VTEP 设备（k8s会在每台物理上创建flannel.1）
- Delivery 头：UDP 协议
- Vxlan 头：vni id 号， 用于区分不同租户的局域网
- Playload：内层包，即真实要发送的包

如何解决 GRE 的问题的：

- 支持组播，新节点都会加入组里，发包时组内的机器都会收到广播包，所以不需要维护隧道信息了，并且基于udp协议搬运包是无状态的
- vni id 是 使用 24 位的 id，几乎没有子网数量的限制。

~~~alert type=note
k8s 中 flannel 基于 vxlan 的模式，vni id 号是固定的，固定值是1；并且 pod 的 mac 地址是静态，由flanneld 进程维护，进行二层通信前不需要发送 arp 广播获取。
~~~



### CIDR

**CIDR** 是 **无类别域间路由** 的缩写。它是在 1993 年引入的一种方法，用于替代传统的 IP 地址分类系统（A类、B类、C类），以解决 IP 地址低效分配和路由表爆炸性增长的问题。

简单来说，**CIDR 是一种更灵活、更高效的 IP 地址分配和管理方法。**

在 CIDR 之前，IP 地址被分为固定的几类：

| 类别 | 范围                        | 网络位 | 主机位 | 子网掩码      | 例子          |
| :--- | :-------------------------- | :----- | :----- | :------------ | :------------ |
| A    | 1.0.0.0 - 126.255.255.255   | 8位    | 24位   | 255.0.0.0     | `10.0.0.0`    |
| B    | 128.0.0.0 - 191.255.255.255 | 16位   | 16位   | 255.255.0.0   | `172.16.0.0`  |
| C    | 192.0.0.0 - 223.255.255.255 | 24位   | 8位    | 255.255.255.0 | `192.168.1.0` |

**传统分类的问题**：不够灵活。一个需要 300 台主机的公司必须申请一个完整的 B 类地址（支持 65,534 台主机），造成巨大浪费。

**CIDR 的解决方案**：不再受 8位、16位、24位的限制，允许**可变长度的子网掩码**。



#### CIDR 的表示法

CIDR 使用一种简洁的表示法：**`IP地址/前缀长度`**

- **IP 地址**：通常是某个网段的起始地址（网络地址）。
- **前缀长度**：表示网络部分的位数。

**例如：`192.168.1.0/24`**

- `192.168.1.0` 是网络地址。
- `/24` 表示前 24 位是网络部分，剩下的 8 位是主机部分。
- 这等价于子网掩码 `255.255.255.0`。

#### 如何理解前缀长度？

一个 IPv4 地址有 32 位。前缀长度就是从左到右数，有多少位用于标识网络。

```text
IP 地址: 192.168.1.0
二进制:  11000000.10101000.00000001.00000000

子网掩码: 255.255.255.0
二进制:  11111111.11111111.11111111.00000000
          ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑ ↑
          前24位是"1"，表示网络部分
```



#### 一个 CIDR 块能容纳多少主机？

公式：**可用主机数 = 2^(32 - 前缀长度) - 2**

为什么要减 2？

- **-1** 给**网络地址**（全0主机位，例如 `192.168.1.0`）
- **-1** 给**广播地址**（全1主机位，例如 `192.168.1.255`）

**常见 CIDR 块示例：**

| CIDR 表示法 | 子网掩码        | 可用 IP 数量 | 主机数量   | 例子          |
| :---------- | :-------------- | :----------- | :--------- | :------------ |
| `/32`       | 255.255.255.255 | 1            | 1          | 单个主机      |
| `/31`       | 255.255.255.254 | 2            | 2*         | 点对点链路    |
| `/30`       | 255.255.255.252 | 4            | 2          | 点对点链路    |
| `/29`       | 255.255.255.248 | 8            | 6          | 小型网络      |
| `/28`       | 255.255.255.240 | 16           | 14         | 小型网络      |
| `/27`       | 255.255.255.224 | 32           | 30         | 小型网络      |
| **`/26`**   | 255.255.255.192 | 64           | 62         | 中型网络      |
| **`/25`**   | 255.255.255.128 | 128          | 126        | 中型网络      |
| **`/24`**   | 255.255.255.0   | 256          | 254        | 经典 C 类网络 |
| **`/23`**   | 255.255.254.0   | 512          | 510        | -             |
| **`/22`**   | 255.255.252.0   | 1024         | 1022       | -             |
| **`/21`**   | 255.255.248.0   | 2048         | 2046       | -             |
| **`/20`**   | 255.255.240.0   | 4096         | 4094       | -             |
| **`/16`**   | 255.255.0.0     | 65,536       | 65,534     | 经典 B 类网络 |
| **`/12`**   | 255.240.0.0     | 1,048,576    | 1,048,574  | -             |
| **`/10`**   | 255.192.0.0     | 4,194,304    | 4,194,302  | -             |
| **`/8`**    | 255.0.0.0       | 16,777,216   | 16,777,214 | 经典 A 类网络 |

*注：`/31` 在某些场景下可用于点对点链路，不保留网络和广播地址。*



#### CIDR 在 Kubernetes 中的关键应用

在 K8s 中，CIDR 概念无处不在：

##### 1. **Pod 网络 CIDR**

```yaml
# 在 kubeadm init 或网络插件配置中指定
# 这是整个集群的 Pod IP 地址池
podSubnet: "10.244.0.0/16"
```

- 这意味着所有 Pod 的 IP 都将从 `10.244.0.0` 到 `10.244.255.255` 这个范围内分配。
- Flannel/Calico 等插件会从这个大池中为每个节点分配更小的子网。

##### 2. **每个节点的 Pod CIDR**

```bash
# 查看某个节点的 Pod CIDR
kubectl get node <node-name> -o jsonpath='{.spec.podCIDR}'
# 输出可能是: 10.244.1.0/24
```

- 每个节点会从集群的 Pod 网络 CIDR 中分得一个更小的块（例如 `/24`）。
- 该节点上创建的所有 Pod 都从这个 `/24` 块中获取 IP。



CIDR 是一个新的 IP 地址分配方式，采用的是可变长的子网掩码，称之为无类别域间路由（消除传统的分A类、B类以及子网划分概念，重新开始） 

在 CIDR 中，IP地址的表达格式为：“IP地址/前缀长度” 。

CIDR 可以把 IP 地址分配和子网划分变得实用和灵活，减少 IP 地址的浪费等。



## 在 k8s 中关于网络划分要考虑的问题

需要考虑的问题：

- 每个 pod 都要有一个独一无二的 ip 地址（因为我们是大二层网络，ip不能冲突）。
- POD 的 IP 地址要够标识 pod 来自于哪台机器。



初始部署 k8s 时为 pod 的网络指定一个大段（`podSubnet: 10.244.0.0/16`，这个配置会创建 2的8次方，也就是 256 个子网络），k8s 会在该大段的基础上进行子网划分，每个节点被分配走一个子网段，该节点上启动的 Pod 都属于自己分配到的网段。

~~~bash
[root@k8s-master-01 ~]# cat kubeadm.yaml | grep networking -A 5
networking:
  dnsDomain: cluster.local
  serviceSubnet: 10.96.0.0/12
  podSubnet: 10.244.0.0/16
scheduler: {}
---
~~~

这么做的好处：

- 每个节点都有自己的一个网段，具有标识性。
- 在访问某个 pod 的 ip 地址时，可以直接确定该 pod 属于哪台物理机，发包效率更高。

虽然不同物理节点上的 pod 拥有各自的网段，看起来像是在不同的网里，但是所有的 pod 都是可以直接二层通信的，ip 地址只是一种标识其独一无二性的一直标识方式。



## flannel 插件

主要两种模式，vxlan（默认）、host-gw

### vxlan 模式

基于 vxlan 协议，采用 vxlan 模式构建的是虚拟大二层网络，底层支撑的物理网络可以是二层也可以是三层。

vxlan 是 flannel 网络插件默认和推荐的模式，它会为每个物理节点分配一个唯一的 24 位子网掩码的子网，调度到这个节点的 pod 就使用这个网段，每个节点都有自己的一个网段，具有标识性。在访问某个pod的ip地址时，可以直接确定该pod属于哪台物理机，发包效率更高



会该在节点上创建两个虚拟网卡：`cni0` 和 `flannel.1`。

- cni0：相当于一个虚拟二层交换机，类似 docker0，该节点上的所有 pod 都通过 veth pair 和 `cni0` 相连。
- flannel.1: 是一个 VTEP 设备，负责 vxlan 协议的封包解包，pod 跨物理节点通信时使用 `flannel.1` 。

查看 veth pair

~~~bash
# 在pod内查看
cat /sys/class/net/eth0/iflink
					
# 宿主机上查看cni0关联的veth设备
bridge link show
~~~

节点内通信，都通过 `cni0` 网桥完成，不涉及 vxlan 报文的封包解包。

跨界点通信，需要通过 `flannel.1` 完成，并且需要使用 flanneld 进程维护的三张表。

- 路由表。路由决策时使用，根据目标 pod 的网段，决定使用 `flannel.1` 设备封包处理。
- arp 表。找到目标 pod 网段对应 `flannel.1` 设备的 MAC 地址，用于封装内层原始二层包。永久不过期。
- fdb 表。根据目标 pod 网段对应 `flannel.1` 设备的 MAC 地址，找到目标 pod 所在节点的 IP，用于封装外层 IP 协议包。

~~~bash
# 查看路由表
route -n

# 查看 arp 表
ip n

# fdb 表
bridge fdb show
~~~



#### vxlan 模式的优缺点

flannel 的 vxlan 模式通过静态配置路由表、ARP 表和FDB 表的信息，结合虚拟网卡 `flannel.1`，实现了一个所有 pod 同属一个大二层的 vxlan 网路模型。

优点：

- 物理网络可以二层也可以是三层，通用性强

缺点：

- 集群规模大时，转发效率较低

适用于：

- 集群群规模几十台，直接使用 flannel 插件默认的 vxlan 模式。



### host-gw 模式

基于路由表来实现转发，把每台物理节点变成路由器。

- 节点内通信，和 vxlan 一样，使用 1`cni01` 网桥通信。
- 跨节点通信，flanneld 设置路由规则，目标 pod 子网的下一跳地址执行对应节点的 IP 地址，使用本节点的 `eth0` 网卡发出去。

host-gw 的核心原理就是由 flanneld 守护进程在每台物理节点上路由，以实现 pod 的跨主机通信，每台物理节点都充当容器通信的“网关”。这也正是“host-gw”的含义。

Flannel 子网和主机的信息保存在 Etcd。flanneld 只需要 WACTH 数据的变化实时更新路由表即可。

Flannel host-gw 模式必须要求集群宿主机之间是二层连通的。在网络中可无法通过 arp 找到 POD 的 mac 地址（ 因为目标 IP 是 pod 的 ip），只能通过目标 mac 地址在二层直接通信。

要使用 host-gw 模式，需要修改 ConfigMap `kube-flannel-cfg` ，将 `Backend.Type` 从vxlan改为host-gw，然后重启所有kube-flannel Pod即可：

~~~bash
[root@k8s-master-01 ~]# kubectl -n kube-flannel edit cm kube-flannel-cfg 
...
net-conf.json: |
{
"Network": "10.244.0.0/16",
"Backend": {
"Type": "host-gw" // <- 改成host-gw
}
}
~~~

或者在部署之初指定配置文件中的配置

~~~bash
wget https://github.com/flannel-io/flannel/releases/latest/download/kube-flannel.yml

[root@master01 flannel]# vim kube-flannel.yml 

apiVersion: v1
data:
...
net-conf.json: |
{
"Network": "10.244.0.0/16", # 与--pod-network-cidr保持一致
"Backend": {
"Type": "vxlan"
}
}

~~~

#### host-gw 模式的优缺点

优点：

- 转发路径少，集群规模大的情况下，转发效率更高。

缺点：

- 要求物理网络必须是二层网络。
- 在一些云平台上会限制你对云主机添加路由条目。



### 总结

VXLAN 是 Linux 内核本身支持的一种网络虚拟化技术，是内核的一个模块，在内核实现封装解封装，构建出覆盖网络，其实就是一个由各宿主机上的 Flannel.1设备组成的虚拟二层网络。

由于 VXLAN 由于额外的封包解包，导致其性能较差，所以 Flannel 就有了 host-gw 模式，即把宿主机当作网关，除了本地路由之外没有额外开销，性能和 calico 差不多。由于没有叠加来实现报文转发，这样会导致路由表庞大，因为一个节点对应一个网络，也就对应一条路由条目。

host-gw 模式虽然比 VXLAN 网络性能要强很多，但是这种方式有个缺陷：要求各物理节点必须在同一个二层网络中，物理节点必须在同一网段中。这样会使得一个网段中的主机量会非常多，万一发一个广播报文就会产生干扰。在私有云场景下，宿主机不在同一网段是很常见的状态，所以就不能使用 host-gw 了。

VXLAN 还有另外一种功能，VXLAN 也支持类似 host-gw 的玩法。如果两个节点在同一网段时使用 host-gw 通信，如果不在同一网段中，即当前 pod 所在节点与目标 pod 所在节点中间有路由器，就使用 VXLAN 这种方式，使用叠加网络。结合了 Host-gw 和 VXLAN，这就是 VXLAN 的 Direct routing 模式。



#### 为什么 host-gw 依赖物理节点是二层互通，而 vxlan 不需要

Host-gw 模式物理节点局域于二层互通是因为路由表中设置的下一条物理节点的 ip 地址必须是可达的，所以下一跳的物理节点 ip 必须是二层互通的。

 vxlan 模式封装了 udp 包之后，再构建外层的 ip 包，使用的目标 ip 地址是目标 pod 的物理节点的 ip 地址，这个 ip 地址是 flanneld 维护的静态数据，可以直接拿到。然后再创建外层以太网层，需要目标 mac 地址，这个可以使用 arp 协议动态获取，所以物理节点可以是二层联通的，也可以是三层联通的，因为使用 arp 动态获取可以拿到。



## calico插件

常用两种模式：BGP、IPIP



### BGP 模式

BGP 模式-与 host-gw 模式几乎一样，也是把宿主机当成一台路由器去用。

~~~bash
<目标容器IP> via <网关ip> dev eth0
~~~

- 其中，网关 IP 就是目标容器所在节点的 IP 地址。



与 host-gw 的区别：

- host-gw 模式下路由信息的维护由 flanneld 进程维护（状态存于与etcd中）
- BGP 模式是由 BGP 协议来自动维护，不需要中心化的数据库（所谓 BGP，就是在大规模网络中实现节点路由信息共享的一种协议）
- BGP模式不会在宿主机上创建 `cni0` 网桥。

~~~alert type=note
BGP（边界网关协议）, 专门用在大规模数据中心里维护不同的自治系统之间路由信息的，是无中心的路由协议。
~~~

>自治系统（AS）：指一个组织管辖下的所有 IP 网络和路由器的全体。一般情况下自治系统和另一个自治系统不会由来往。但如果两个自治系统里面的主机要通过 IP 地址通信，就需要使用路由器把这两个自治系统连接。
>
>把 AS 连接在一起的路由器称为边界网关。跟普通路由器的不同之处在于它的路由表里拥有其他 AS 里的主机路由信息。
>
>在复杂的网络结构中如果还依靠人工来对边界网关的路由表进行配置和维护，那是绝对不现实的。
>
>这时 BGP 大显身手的时刻就到了。BGP 在每个边界网关上运行一个程序，将各自的路由表信息，通过 TCP 传输给其他的边界网关。其他边界网关上的这个程序对收到的数据进行分析，将需要的信息添加到自己的路由表。
>
>所谓 BGP，就是在大规模网络中实现节点路由信息共享的一种协议。
>
>而 BGP 正好可以取代 Flannel 维护主机上路由表的功能。BGP 这种原生就是为大规模网络环境而实现的协议，其可靠性和可扩展性，远非 Flannel 自己的方案可比。



BGP 模式的三个组成部分

- CNI 插件：为 pod 创建 veth 对，并为 veth pair 增加路由规则。
- Felix：是一个守护程序（在k8s中以DeaemonSe部署），以 agent 形式运行在宿主机上，负责在宿主机上插入路由规则（即：写入 Linux 内核的 FIB 转发信息库），以及维护 Calico 所需的网络设备等工作。
- BIRD。BGP 的客户端，作用是读取 Felix 编写到内核中的路由信息，并将路由信息分发到集群中的其他节点。



BGP 模式下，没有 `cni0` 网桥，pod 和 宿主机之间使用 veth pair 连接，CNI 插件在宿主机上为每个容器的 veth pair 设备增加一条路由规则。容器发出来的 IP 包经过 veth pair 出现在宿主机上。宿主机根据路由规则的下一跳 IP 地址，把他们转发给正确的网关。接下来的流程就和 flannel host-gw 模式一样了。

最核心的 "下一跳" 路由规则，就是由 Calico 的 Felix 进程负责维护的。这些路由规则信息，是通过 BGP Client 也就是 BIRD 组件，使用 BGP 协议传输而来的。

而通过 BGP 协议传输的消息可以简单地理解为如下格式：

~~~bash
[BGP 消息]
我是宿主机 192.168.1.3
10.233.2.0/24 网段的容器都在我这里
这些容器的下一跳地址是我
~~~

Calico 实际上将集群里的所有节点都当作是边界路由器来处理，一起组成了一个全连通的网络，互相之间通过 BGP 协议交换路由规则。这些节点称为 BGP Peer。



#### BGP Route Reflector

Calico 维护的网络在默认配置下，每个节点的 BGP Client 需要与其他所有节点建立 BGP 连接。连接数随节点数 N 呈 N² 增长。适用于小规模集群，大规模集群下网络压力大。

Route Reflector 模式（用于大规模集群）：

- 指定一个或多个专用节点作为 Route Reflector。
- 这些节点与所有节点建立 BGP 连接，学习全局路由规则。
- 其他节点只需与 Route Reflector 节点交换路由信息。
- 连接数控制在 N 的数量级，降低网络压力。



#### BGP 模式总结

优点：

- 大规模集群

缺点：

- 要求物理网络必须是二层网络。
- 在一些云平台上会限制你对云主机添加路由条目。



### IPIP隧道模式

IPIP隧道与 flannel 插件的 vxlan 模式类似，本质就是协议封装，底层的物理网络可以是二层也可以是三层。

效率比 vxlan 略高，但是维护成本也高，了解即可。



