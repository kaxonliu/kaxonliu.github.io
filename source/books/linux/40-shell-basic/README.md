# Linux系统构成和shell基础

想要认识Linux操作系统的组成，可以从两个维度入手，分别是功能维度和文件维度。

## 功能维度

因为操作系统起到承上启下的角色，因此在供能上一方面要对接上层应用程序，另一两面要和底层操作系统打交道。因为上层应用程序无法直接控制硬件，需要给操作系统发出调用硬件的请求，操作系统来调用硬件然后把结果返回给应用程序。

在这个过程中，操作系统就会在上层应用程序和底层硬件之间来回切换状态，因此操作系统有两个状态，分别是用户态和内核态。**用户态指的是此时操作系统正在和上层应用程序打交道**。**内核态指的是此时操作系统正在和底层硬件打交道**。

## 文件维度

操作系统本质上也是一个程序，它也有一堆文件，这些文件源自ISO镜像包。这些文件可以分为两类：**`bootfs` 和 `rootfs`**。前者用于操作系统的启动，里面包含操作系统启动需要的文件。后者用于操作系统启动后运行时使用的，就是根目录及其文件夹/文件。

>补充，操作系统启动时会执行硬盘上第一个扇区的bootloader程序，它会把内核文件加载到内存，然后CPU执行就把操作系统启动运行起来。





## Linux操作系统启动顺序

启动顺序说了很多遍了，再来一遍也无所谓，加深印象。

1. 通电，开机找到并启动 bios；
2. bios找到启动盘，读取启动盘上第一个扇区中的主引导记录，加入内存，让CPU执行并启动bootloader；
3. bootloader从硬盘上找到内核文件并读如内存，CPU执行，操作系统启动；
4. 操作系统启动后开始管理一系列进程。





## Linux如何管理进程

操作系统启动后会负责管理一系列的进程，这些进程可以分为两大类。它的管理方式很简单，操作系统内核先启动一个根进程，pid为0。根进程会创建两个子进程，分别负责管理所有的用户态进程和内核态进程。

- 用户态的根进程为 systemd，pid为1，是所有用户态进程的祖宗。
- 内核态的根进程为 kthreadd，pid为2，是所有内核态进程的祖宗。

>补充，在centos7以前用户态进程名字为 init，后续版本调整为 systemd，但是依然保留着 init，通过 ls 命令可以看到通过软连接的方式指向 systemd
>
>~~~bash
>[root@VM-12-14-centos ~]# ls -l /usr/sbin/init 
>lrwxrwxrwx 1 root root 22 Mar 23  2023 /usr/sbin/init -> ../lib/systemd/systemd
>[root@VM-12-14-centos ~]# 
>~~~
>
>ubuntu系统中依然保留着用户态根进程的名字为 init





## Linux系统启动级别

有七个启动级别：

1. 运行级别为0，指的是关机状态
2. 运行级别为1，指的是单用户工作状态，不能远程登陆
3. 运行级别为2，指的是多用户状态（无NFS）
4. 运行级别为3，指的是多用户状态（NFS），登陆后进程控制台命令模式
5. 运行级别为4，系统保留，未使用
6. 运行级别为5，指的是进入GUI图形界面模式（提前安装了图形界面工具）
7. 运行级别为6，重启

>补充1，安装图形桌面的命令   `yum -y group install "Server with GUI"`
>
>补充2，切换系统运行的级别使用 init 命令，比如切换到GUI模式 `init 5`
>
>补充3，获取系统的默认启动级别使用下面的命令 `systemctl get-default`
>
>补充4，修改默认系统级别
>
>~~~bash
># 设置为多用户状态
>systemctl set-default multi-user.target
>
># 设置为图形界面
>systemctl set-default graphical.target
>~~~



## shell解释器

在默认启动级别为3的情况下，操作系统启动后默认执行并启动一个命令解释器，也称之为字符终端，只能在这个终端中敲指令并输出字符。linux系统中的命令解释器称之为 shell（中文为壳的意思），表达了对系统接口封装的思想。shell解释器有很多种，默认使用的是 bash 这一款。





## shell交互式环境

登陆操作系统后，默认进入的就是 shell 交互式环境，在交互式环境中表现为输入指令然后得到输出反馈。

~~~bash
# 超级管理员 root 登陆后的界面
[root@VM-12-14-centos ~]# pwd
/root
[root@VM-12-14-centos ~]# 


# 普通用户 lighthouse 登陆后的界面
[lighthouse@VM-12-14-centos ~]$ pwd
/home/lighthouse
[lighthouse@VM-12-14-centos ~]$ 
~~~

其中，`root` 表示当前用户为 root，`@` 是分隔符，`VM-12-14-CENTOS` 表示主机名，`~` 表示当前用户的家目录，使用 shell 命令 `pwd` 查看用户当前所在的目录。

超级管理员的家目录是 `/root`，普通用户的家目录是 `/home/<用户名>`。

`#` 表示当前登陆的用户是超级管理员。 `$` 表示当前登陆的用户是普通用户。



**shell命令的基本语法**

~~~bash
[root@VM-12-14-centos ~]# ls -l /boot
[root@VM-12-14-centos ~]# ls -l
[root@VM-12-14-centos ~]# ls /boot
~~~

上述是一个基本的shell 命令，以小见大，可以看到 shell 命令的使用包括三个部分：命令、选项、参数

- 命令，表示要做什么事情（必选）
- 选项，标识具体做什么（可选）
- 参数，命令具体操纵的目标（可选）



**交互式环境的常用快捷方式**

	ctrl+c: 强制终止当前命令的执行
	ctrl+l：清屏，等同于 clear 命令
	ctrl+a   光标移到命令行的最前端
	ctrl+e   光标移到命令行的后端
	
	tab键补全
	上下箭头 查出历史命令
	history 查出命令的编号，然后!编号 可以执行这个命令
	history -c # 清空历史记录
	
	!$ # 取上一条命令的参数



## shell 命令的种类

**带着路径的命令**

这种命令有很多，比如 `ls` 、`pwd` 等等，我们可以直接使用是因为环境变量的原因。抛开环境变量不谈，这种方式使用的命令都是带着路径的命令，比如 `pwd` 就是 `/bin/pwd`。当然了这种路径既可以是绝对路径，也可以是相对路径。

~~~bash
[root@VM-12-14-centos ~]# pwd
/root
[root@VM-12-14-centos ~]# which pwd			# 使用which命令可以查看命令的位置
/bin/pwd
[root@VM-12-14-centos ~]# /bin/pwd
/root
[root@VM-12-14-centos ~]# 
~~~

>补充，shell 中使用 `.` 表示当前目录，使用 `..` 表示上一层目录。



**别名的命令**

这种指的是给一个复杂的命令起一个简单的别名，使用别名的效果等同于原命令。使用命令 `alias` 设置别名。

~~~bash
[root@VM-12-14-centos ~]# cat /etc/resolv.conf 
; generated by /usr/sbin/dhclient-script
nameserver 183.60.83.19
nameserver 183.60.82.98
[root@VM-12-14-centos ~]# alias xxx="cat /etc/resolv.conf"
[root@VM-12-14-centos ~]# xxx
; generated by /usr/sbin/dhclient-script
nameserver 183.60.83.19
nameserver 183.60.82.98
[root@VM-12-14-centos ~]# 
~~~

使用 `alias` 需要注意两点。第一设置别名时 `=`前后不能有空格。第二上述设置别名只在当前终端有效，退出后失效；当然了可以通过其他方式设置为永久有效。取消别名使用命令 `unalias`，如 `unalias xxx`。



**复合命令**

~~~bash
[root@VM-12-14-centos ~]# for ((i=1;i<=10;i++)); do echo "hello"; done
hello
hello
hello
[root@VM-12-14-centos ~]# 
~~~



**函数命令**

通过function定义命令

~~~bash
# 1、定义, 使用 function关键字定义函数 f, {} 内部的命令必须以 ; 结尾 
function f() {
    echo 111;
    echo 222;
    echo 333;
}
		
# 2、调用时直接使用函数名
f 
~~~



**内置命令 builtin**

内置在 shell 解释器中的命令，不会临时创建额外的进程。可以使用命令 `type` 查看命令是否是内置命令。

~~~bash
[root@VM-12-14-centos ~]# type cd
cd is a shell builtin
[root@VM-12-14-centos ~]# type pwd
pwd is a shell builtin
[root@VM-12-14-centos ~]# type useradd
useradd is /sbin/useradd								# useradd不是内置命令
[root@VM-12-14-centos ~]# 
[root@VM-12-14-centos ~]# type type
type is a shell builtin
~~~



**环境变量PATH**

环境变量是系统级别的，与命令查找有关系。查看环境变量中有哪些值，使用命令 `echo $PATH`，可以看出环境变量中存的是一些文件夹，并且是都是存放命令文件的的文件夹，每个文件夹通过 `:` 分割。

~~~bash
[root@node1 ~]# echo $PATH
/usr/local/sbin:/sbin:/bin:/usr/sbin:/usr/bin:/root/bin
~~~

如果我们想要一个自定义命令执行时不要带上路径，那可以把这个自定义命令放在环境变量中的一个文件夹里面。有两种方式，第一：把自定义命令移动到环境变量中已经存在的文件夹里面；第二：把自定义命令所在文件夹追加到环境变量中。

追加环境变量的方式：`PATH=$PATH:/root`，把 /root 文件夹追加到环境变量中。注意：这种方式时临时的，退出当前 shell 则失效。



## 命令的优先级

1. 带路径的命令
2. 别名
3. 复合命令
4. 函数名
5. 内置命令
6. 环境变量中的命令





## shell脚本

Shell 交互式环境中可以使用很多命令，但都是一次性的，不能重复使用。把这些命令写在一个文件中，就构成了一个脚本程序，程序指的就是一个文件。有了shell脚本文件，我们的多个命令就可以一次编写，多次使用。

Shell 脚本需要赋予可执行权限。

~~~bash
chmod +x /root/my_shell_file
~~~





## 简单常用命令（常用）

- 查看主机名：`hostname`
- 设置主机名：`hostnamectl set-hostname node1` ，这种方式直接修改文件 `/etc/hostname` 为永久设置
- 查看 IP 地址：`ip a` 或者 `ifconfig`，如果没有 `ifconfig` 则需要安装工具包 `net-tools`
- 查看网卡信息：`ifconfig eth0`
- 激活网卡：`ifconfig eth0 up`
- 激活网卡：`nmcli conn up eth0`，推荐使用
- 查看日期时间：`data`，`date "+%F"`，`date "+%Y-%m-%d %H:%M:%S"`
- 重启：10分钟后重启`shutdown -r 10`，立即重启：`shutdown -r now`，`reboot`
- 关机：10分钟后重启`shutdown -h 10`，立即重启：`shutdown -h now`
- 取消将要执行的关机或重启任务：`shutdown -c`





