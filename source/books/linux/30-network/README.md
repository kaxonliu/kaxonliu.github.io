# 网络协议基础

## CS架构&BS架构

互联通信软件有两种模式：CS架构和BS架构，其中：

- CS 指的是 Client-Server，一个客户端软件和一个服务端软件
- BS 指的是 Browser-Server，一个浏览器和一个服务端软件

~~~
客户端软件send                 服务端软件recv
操作系统                       操作系统
计算机硬件 <====物理介质=====>  计算机硬件
~~~





## 什么是网络

**网络 = 物理链接介质 + 互联网通信协议**

网络存在的意义是为了解决跨地域数据传输的困难, 也就是解决通信的困难。互联网的本质就是一系列的网络协议。互联网协议的功能：定义计算机如何接入internet，以及接入internet的计算机通信的标准。





## 网络体系结构

把计算机网络的各层及其协议的集合，称为网络的体系结构。

互联网通信协议根据历史的发展分别有：OSI七层协议、TCP/IP四层协议、TCP/IP五层协议

![img](osi.png)

OSI七层协议是国际标准化组织ISO提出的，但由于市场原因和该协议本身的缺点（协议实现过一复杂，层次划分不太合理等）导致起初市场上大规模使用的并不是该协议，而是因特网。所以有这样一个现象：得到最广泛应用的不是法律上的国际标准OSI，而是非国际标准TCP/IP。这样TCP/IP成为了事实上的国际标准。



OSI七层协议体系结构的概念清楚，理论也比较完整，但它既复杂又不实用。TCP/IP体系结构则不同，它现在已经得到了非常广泛的应用。TCP/IP是一个四层的体系结构。因为最下面的网络接口层基本上和一般的通信链路在功能上没有多大区别，对于计算机网络来说，这一层并没有特别新的具体内容。因此在在学习计算机网络的原理是往往采取折中的办法，即综合OSI和TCP/IP的优点，采用一种只有五层协议的体系结构，这样既简洁又能将概念阐述清楚。



TCP/IP代表传输控制协议/网际协议，指的是一系列协组。所谓协议，九四规定数据的组织格式（格式：头部部分 + 数据部分）。





## 物理层

物理层由来：上面提到，孤立的计算机之间要想一起玩，就必须接入internet，言外之意就是计算机之间必须完成组网。

物理层功能：主要是基于电器特性发送高低电压(电信号)，高电压对应数字1，低电压对应数字0

```python
# 一组物理层数据称之为：位
# 单纯的电信号毫无意义，必须对其进行分组
```



## 数据链路层

数据链路层由来：单纯的电信号0和1没有任何意义，必须规定电信号多少位一组，一组是什么意思。

数据链路层的功能：定义了电信号的分组方式

数据链路层：遵循**以太网协议**（ethernet）

```python
# 以太网协议的基本内容

规定1：一组数据称之为一个数据帧
规定2：数据帧分成两部分：头 + 数据
- 头包含：源地址与目标地址，该地址是mac地址
- 数据包含：包含的是网络层发过来的整体的内容

规定3：但凡接入互联网的主机必须有一块网卡，每块网卡在出厂时都烧制好一个全世界独一无二的地址，该地址称之为mac地址

head包含：(固定18个字节)
发送者／源地址，6个字节
接收者／目标地址，6个字节
数据类型，6个字节
data包含：(最短46字节，最长1500字节)

数据包的具体内容
head长度＋data长度＝最短64字节，最长1518字节，超过最大限制就分片发送

head中包含的源和目标地址由来：ethernet规定接入internet的设备都必须具备网卡，发送端和接收端的地址便是指网卡的地址，即mac地址
mac地址：每块网卡出厂时都被烧制上一个世界唯一的mac地址，长度为48位2进制，通常由12位16进制数表示（前六位是厂商编号，后六位是流水线号）
```

有了mac地址，同一个网络内的两台主机就可以通信了（一台主机通过**arp协议**获取另外一台主机的mac地址）。ethernet采用最原始的方式，**广播的方式进行通信**。





## 网络层

网络层由来：有了ethernet、mac地址、广播的发送方式，世界上的计算机都在一个网络内就可以彼此通信了，但是全世界的电脑数量是海量的，如果都在一个网络内通过广播的方式通信，那效率是非常低效的。因此必须拆分，将网络拆分成多个局域网。那必须找出一种方法来标识局域网，如果多个主机在一个局域网内那就可以采用广播的方式发送；如果不是，则采用其他方式通信。

网络层功能：引入一套新的地址用来区分不同的局域网／子网，这套地址即网络地址（IP地址）。

网络层：遵循 **IP协议**

>扩展：一个局域网但凡要接通外网/公网，一定要有一个网关帮内部的计算机转发包到公网。网关与外界通信走的是路由协议。





### IP协议

- 规定网络地址的协议叫ip协议，它定义的地址称之为ip地址，广泛采用的v4版本即ipv4，它规定网络地址由32位2进制数表示
- 范围0.0.0.0-255.255.255.255
- 一个ip地址通常写成四段十进制数，例：172.16.10.1



**ip地址分成两部分**

- 网络部分：标识子网
- 主机部分：标识主机

注意：**单纯的ip地址段只是标识了ip地址的种类，从网络部分或主机部分都无法辨识一个ip所处的子网，需要结合子网掩码来判断**。例如：172.16.10.1 与 172.16.10.2 并不能确定二者处于同一子网



### 子网掩码

所谓”子网掩码”，就是表示子网络特征的一个参数。它在形式上等同于IP地址，也是一个32位二进制数字，它的网络部分全部为1，主机部分全部为0。比如，IP地址172.16.10.1，如果规定网络部分是前24位，主机部分是后8位，那么子网络掩码就是11111111.11111111.11111111.00000000，写成十进制就是255.255.255.0。

~~~
# ip地址和子网掩码的书写方式一般有两种，
第一种：分别书写，如：ip地址172.16.10.2、子网掩码255.255.255.0
第二种：写在一块，如 172.16.10.2/24			(24表示前24位都是1，等同于 255.255.255.0)
~~~



### 计算两个ip地址是否在一个网络

知道”子网掩码”，我们就能判断，任意两个IP地址是否处在同一个子网络。将IP地址和子网掩码都换算成二进制，然后进行与运算，结果就是网络地址。**网络地址相同则在一个局域网内**。

```python
# 判断两个IP地址是否处于一个自网络内：
将两个IP地址与子网掩码分别进行AND运算（两个数位都为1，运算结果为1，否则为0），然后比较结果是否相同。
如果是的话，就表明它们在同一个子网络中，否则就不是。
# 应用：
已知IP地址172.16.10.1和172.16.10.2的子网掩码都是255.255.255.0，请问它们是否在同一个子网络？
两者与子网掩码分别进行AND运算，

10101100.00010000.00001010.00000001		 IP地址 172.16.10.1
11111111.11111111.11111111.00000000		 子网掩码 255.255.255.0
10101100.00010000.00001010.00000000    AND运算得到的网络地址结果 172.16.10.0


10101100.00010000.00001010.00000010		 IP地址 172.16.10.2
11111111.11111111.11111111.00000000		 子网掩码 255.255.255.0
10101100.00010000.00001010.00000000    AND运算得到的网络地址结果 172.16.10.0

结果都是172.16.10.0，因此它们在同一个子网络。
```

总结一下，**IP协议的作用主要有两个**：1. 标识一个局域网 ；2. 为每一台计算机分配IP地址(ip要和mac地址关联)。



### ip数据包

```python
# ip数据包也分为head和data部分，ip数据包直接放入以太网包的data部分
head：长度为20到60字节, head种包含源地址与目标地址，该地址是IP地址
data：最长为65,515字节，data包含的传输层发过来的整体的内容
而以太网数据包的”数据”部分，最长只有1500字节。因此，如果IP数据包超过了1500字节，它就需要分割成多个以太网数据包，分开发送。
```



### ARP协议

arp协议由来：计算机通信基本是广播的方式，所有上层的包到最后都要封装上以太网头，然后通过以太网协议发送，在谈及以太网协议时候，我们知道通信是基于mac的广播方式实现，计算机在发包时，获取自身的mac是容易的，**如何获取目标主机的mac，就需要通过arp协议**。ARP协议功能：根据 **IP地址** 获取对应 **MAC地址**。

#### ARP 的工作原理

**（1）ARP 请求（广播）**

- 当主机 A 想与主机 B（IP 已知）通信，但不知道 B 的 MAC 地址时：
  1. 主机 A 检查自己的 **ARP 缓存表**（存储 IP-MAC 映射）。
  2. 如果未找到 B 的 MAC 地址，主机 A 发送 **ARP 请求广播包**（目标 MAC = `FF:FF:FF:FF:FF:FF`），询问：“谁的 IP 是 `B的IP`？请告诉 `A的MAC`。”

**（2）ARP 响应（单播）**

- 主机 B 收到 ARP 请求后：
  1. 发现请求的 IP 是自己的，于是向主机 A 发送 **ARP 响应包**（单播），包含自己的 MAC 地址。
  2. 主机 A 收到响应后，将 B 的 IP-MAC 映射存入 ARP 缓存表，后续通信直接使用。

#### ARP 的局限性

- **ARP 欺骗（ARP Spoofing）**：攻击者伪造 ARP 响应，篡改 IP-MAC 映射，导致流量劫持（中间人攻击）。
- **广播风暴**：大量 ARP 请求可能占用网络带宽。
- **仅限局域网**：ARP 不能跨路由器工作（路由器会隔离广播域）。



### 同局域网通信

局域网内的两台主机通信，发送端发现接受端的 IP 和自己的 IP 处于一个网络内，于是知道可以通过以太网协议规定的广播的方式通信，那剩下需要做的事情就是获取接受端的 MA C地址。此时发送端发送 ARP 请求广播包，

~~~
发送端的MAC地址 FF:FF:FF:FF:FF:FF 发送端的IP地址 接受端的IP地址
~~~

接受端遵循 ARP 协议，收到这个请求包后一定会回一个响应包，告诉发送端自己的 MAC 地址。拿到接受端的MAC 地址后，发送端就可以通过广播的方式向发送端发送一个通信的广播包了，接受端收到后给出响应即可。

~~~
发送端的MAC地址 接收端的MAC地址 发送端的IP地址 接受端的IP地址 数据部分
~~~

>补充：局域网内的机器通信使用交换机。交换机是二层设备



### 跨局域网通信

发送端发现接收端的 IP 和自己的 IP 不在一个网络内，于是知道不能通过局域网内广播的方式通信。于是就向自己所在的局域网发送一个 ARP 请求广播包，

~~~
发送端的MAC地址 FF:FF:FF:FF:FF:FF 发送端的IP地址 发送端局域网网关IP地址
~~~

发送端内的网关也是局域网内的一员，接收到上述 ARP 请求广播包也会给出一个响应包，告诉发送端自己的 MAC 地址。拿到自己所在局域网网关的 MAC 地址后，发送端通过广播的方式向网关发送一个通信的广播包。网关收到这个广播包后，知道这个包要发送到外网，于是使用路由的方式将数据包向外发送出去。

~~~
发送端的MAC地址 发送端局域网网关MA地址 发送端的IP地址 接受端的IP地址 数据部分
~~~

> 补充：网关其实是路由器，路由器是三层设备。家庭常用的路由器是路由器 + 交换机的合体，实现了两者的功能。





## 传输层

传输层的由来：网络层的 IP 地址帮我们标识局域网，以太网层的 MAC 地址帮我们找到主机。但是我们写网络通信软件最主要的是找到目标计算机上的某个软件，上面的mac+ip还不能实现这个需求。这就需要再提出一个端口的概念。端口即应用程序与网卡关联的编号。

**传输层功能：建立端口到端口的通信**

```python
补充：端口范围0-65535，0-1023为系统占用端口
客户端软件的端口号是由操作系统动态分配的。一个机器上的端口号不能冲突。
服务端软件的端口号是绑定的，不能变的。
```

传输层遵循的协议有两个：**TCP协议和UDP协议**，都是基于端口工作。

```python
mac + ip 标识唯一一个主机
ip + port 标识唯一一台主机上的一个基于网络通信的软件
```

tcp头里面放的是源端口和目标端口，udp头也一样。

```python
# tcp协议
可靠传输，TCP数据包没有长度限制，理论上可以无限长，但是为了保证网络的效率，通常TCP数据包的长度不会超过IP数据包的长度，以确保单个TCP数据包不必再分割。
# 至此：数据包装结果
以太网头 --> ip头 --> tcp头 --> 数据   

# udp协议
不可靠传输，”报头”部分一共只有8个字节，总长度不超过65,535字节，正好放进一个IP数据包。
# 至此：数据包装结果
以太网头 --> ip头 --> udp头 --> 数据
```

### TCP协议

tcp协议又称好人协议，只要收到请求，就要发出一个确认响应。这也是从安全性的角度出发产生的一个'漏洞'。

**tcp报文**

![tcp](tcp.png)

tcp协议又称可靠协议：**tcp的请求确认机制是保证数据安全的原因，但这是以牺牲数据传输效率为代价的。**

tcp协议要求通信之间必须建立好双向通路。



### 三次握手简述流程

```
<1> 客户端作为主动方，首先向服务端发一个建立连接的请求。
<2> 服务端接收到请求后，回复同意。
<3> 然后服务端也要向客户端发一个请求建立连接。
<4> 客户端收到请求后，回复同意
```

>注意：<2>和<3>是**两个连续从服务端发出的消息，可以合并为一个回复并请求。整个过程就是三次握手建立TCP连接**



### 三次握手详细流程分析

1. 握手连接前的状态，TCP客户端A和TCP服务端B都处于关闭状态(CLOSED)。注意：A主动打开连接，B被动打开链接。
2. 服务端B先启动，准备接收客户端的连接请求，然后服务端就进入监听状态(LISTEN)，等待客户端的连接请求。
3. 客户端A启动，向服务端B发出连接请求报文段，此时A进入SYN-SENT状态。
4. 服务端B收到连接请求后，如同意建立连接，则向A发送确认。同时也发送一个报文请求段，注意此时服务端不能携带数据。 服务端进入SYN-RCVD状态。
5. 客户端A收到服务端B的确认后，还要向服务端B给出确认。TCP规定此时报文段可以携带数据。但如果不携带数据时不会消耗一个序 号，在这种情况下，下一个数据报文段的序号仍是seq=x+1。这时，TCP连接已经建立，A进入ESTABLISHED状态。
6. 等B收到A的确认后，也进入ESTABLISHED状态。

![tcp_3_handshake.jpg](tcp_3_handshake.jpg)

```python
# 上面给出的建立连接的过程叫做三次握手（three-way handshake）。
# 客户端A最后一次还要再发送一次确认是有必要的，这主要是为了防止已失效的连接请求报文段突然又传送到了B，因而产生错误。

# 正常情况下：
服务端会大多数时间处在LISTEN状态，有正常客户端进来时，会瞬间经历SYN-RCVD状态快速到ESTABLISHED，等数据发送结束后又进入LISTEN状态。
客户端在SYN-SENT状态的时间非常短，多数处于入ESTABLISHED状态，断开与服务端连接后不再是ESTABLISHED状态。

# 非正常客户端：SYN-洪水攻击,模拟大量假的客户端向服务端发请求，占用服务端的资源，正常的客户端就进不去。
服务端大量处于：SYN-RCVD状态可能处于洪水攻击，也可能处于大并发状态。
当触发洪水攻击时，服务端也不会一直处于SYN-RCVD状态，但会浪费大量的时间在此处。
```

>**补充：SYN-洪水攻击**
>
>```python
>非法分子模拟大量假的客户端给服务端发一个消息就跑了，然后服务端浪费大量时间在SYN-RCVD等待状态，严重占用正常客户端的访问。
>```
>
>**补充：半连接池**
>
>```python
>tcp协议有一个半连接池的概念，又称backlog。它的本质是一个队列，一般backlog最大数量是128个
>它的目的是为了让服务端起到缓冲的作用。当客户端的请求过多时，请求先到半连接池等待服务端的挨个处理。
>一边处理请求，一般新的请求再依次进入半连接池。
># 半连接池无法解决SYN-洪水攻击。
>```



### 四次挥手简述流程 

```
<1> 客户端柱或服务端都可以主动断开连接，假定客户端主动申请断开连接
<2> 服务端接收到请求后，回复同意。
<3> 然后服务端要再向客户端发一个请求断开连接。
<4> 客户端收到请求后，回复同意
```

>注意：<2>和<3>**不能合并为一个挥手，因为服务端收到断开连接请求后可能还有数据未发送给客户端，需要把数据发送完毕后才能向客户端申请断开连接，整个过程就是四次挥手断开连接。**



### 四次挥手详细流程分析

![img](tcp_4_byebye.jpg)

**挥手流程分析**：

1. 数据传输后，通信的双方都可以主动释放连接。现在A和B都处于ESTABLISHED状态。
2. A停止发送数据，主动关闭TCP连接。这时A进入终止状态1状态（FIN-WAIT-1），等待B的确认。注意，TCP规定FIN报文即 使不携带数据，也要消耗一个序号。即此时的u是上一次字节序号加1。
3. B收到连接释放报文段后即发出确认。然后B进入关闭等待状态（CLOSE-WAIT）。这时TCP连接处于半关闭状态（half-close），即A已经没有数据要发了，但若B发送数据，A仍要接收。也就是说从B到A这个方向的连接没有关闭，这个状态要持续到B给A发送完所有数据后。
4. A收到来自B的确认后，进入终止等待2状态（FIN-WAIT-2），等待B发出连接释放报文段。
5.  若B发完数据，就会发释放连接FIN报文段。B还必须重复上次发过的确认好ack=u+1。这时B进入最后确认状态（LAST-ACK），等待A的确认。
6.  A收到B的连接释放报文段后，必须对此发出确认。然后进入时间等待状态（TIME-WAIT）。
7. B收到A的确认信息后，按照步骤进入关闭状态（CLOSED）。
8. 注意, 此时TCP连接还没有释放掉。A必须经过时间等待计时器（TIME-WAIT timer）设置的时间2MSL后, A才进入CLOSED状态。

```python
# 补充，A必须在TIME-WAIT状态下等待2MSL。目的有两个：
- 第一是保证A先进入CLOSED状态；
- 第二是为了防止已失效的连接请求报文段突然又传送到了B，因而产生错误。

# B只要收到了A发出来的确认，就进入CLOSED状态。A必须等待2MSL。这就表明，B结束TCP连接的时间要比A早一些，这是提前结束连接的代价。
# 现实中，一般服务器要处理多个客户端用户，所以服务端一般处理完一个客户端的请求就会主动终止TCP连接，服务端多是4次挥手的发起者。
# 当服务端大量处于TIME-WAIT状态，意味着服务端正在经历高并发。
```

### UDP协议

udp协议特点：

- UDP是无连接的，即发数据之前不需要建立连接，同理发送数据结束也没有连接可释放，这极大减少了开销和发送数据之前的时延。
- UDP不保证数据的可靠交付，只负责将数据尽可能快的发出去。



## 应用层

应用层由来：用户使用的都是应用程序，均工作于应用层，互联网是开发的，大家都可以开发自己的应用程序，数据多种多样，必须规定好数据的组织形式 。

应用层功能：规定应用程序的数据格式。

应用层常见的协议：HTTP、FTP等



**每层都有自己的协议**

![img](osi2.png)



### DNS协议

DNS是域名解析服务器（domain name server），也可以成为域名解析协议，负责将域名解析为ip地址，它基于udp协议实现的。

>补充：域名是为了人类可读，便于记忆和访问。

```python
13台根dns：
A.root-servers.net198.41.0.4美国
B.root-servers.net192.228.79.201美国（另支持IPv6）
C.root-servers.net192.33.4.12法国
D.root-servers.net128.8.10.90美国
E.root-servers.net192.203.230.10美国
F.root-servers.net192.5.5.241美国（另支持IPv6）
G.root-servers.net192.112.36.4美国
H.root-servers.net128.63.2.53美国（另支持IPv6）
I.root-servers.net192.36.148.17瑞典
J.root-servers.net192.58.128.30美国
K.root-servers.net193.0.14.129英国（另支持IPv6）
L.root-servers.net198.32.64.12美国
M.root-servers.net202.12.27.33日本（另支持IPv6）
```

DNS的解析过程有两个，分别是递归和迭代。具体的解析可以使用命令 `dig` 查看。比如查看域名`kaxonliu.github.io` 的解析过程。

~~~bash
dig +trace kaxon.github.io
~~~

>在centos上安装工具包后才可以使用命令 dig
>
>~~~bash
>yum install -y bind-utils
>~~~

<img src="dns.png" style="zoom:67%;" />

**DNS缓存分类**

1. 浏览器DNS缓存（内存中): 浏览器会按照一定频率缓存DNS记录；
2. 本地HOSTS文件（硬盘中）；
3. 本地操作系统DNS缓存；
4. 路由器指定的DNS(远程): 路由器自动获取DNS地址；
5. ISP的DNS服务器（远程）:  ISP(Internet Service Provider互联网服务提供商、联通电信移动)，ISP有专门的DNS服务器应 对DNS查询请求；
6. 根服务器（远程，跨国）: ISP的DNS服务器还找不到的话，它就会向根服务器发出查询请求。



**DNS解析记录类型**

~~~text
1 A记录 把域名解析为IP
		example.com.   IN   A   192.0.2.1
		
2 AAAA记录 把域名解析为ipv6地址
		example.com.   IN   AAAA   2001:0db8:85a3:0000:0000:8a2e:0370:7334
		
3 CNAME记录 把域名解析为另一个域名（别名）
		www.example.com.   IN   CNAME   example.com.
		
4 MAX记录 域名邮件解析
5 NS记录 指定域名的权威DNS服务器
6 PTR记录 反向DNS查找
7 TXT记录 任意文本信息，常用语验证域名所有权
~~~





## 网络通信流程总结

基于网络通信的软件有两种：BS架构、CS架构。不同之处在于BS架构没有客户端软件，它依赖浏览器（特殊的客户端）。在网络通信流程方面的不同之处在于，BS架构的软件在客户端（浏览器网址输入栏）多一个DNS域名解析过程。在浏览器的网址输入栏上输入一个网址，按回车键到获取页面响应信息发生了：

```python
<1> 本机的DNS域名解析系统启动，获取域名对应的ip地址交给浏览器。
<2> TCP/IP封包过程，主要将浏览器输入栏中的虚拟路径和其他信息作为基本数据依次打包。
<3> 通过网络传输到对方主机，依次解包，对方主机应用层软件获取这个虚拟路径对应的资源，原路返回响应给客户端。
<4> 本地主机接收到响应信息，依次解包，获取请求的资源。
<5> 至此完成一次网络通信交流流程。
```

比如，我们访问：https://kaxonliu.github.io/books/linux/basic/index.html

- 首先DNS协议启动工作，获取域名对应的ip
- 应用层将网页数据打包一个https协议的协议头，将这个包交给传输层。
- 传输层基于TCP协议，将应用层下交的数据再打包一个tcp头，这个头包含自己浏览器的端口和对方主机的端口。再将数据交给网络层。
- 网络层拿到数据后，再打包一个ip头，包含自己主机的ip和对方主机的ip。将包裹下交给数据链路层。
- 数据链路层拿到数据后，发现两个ip地址的网络地址不同，判断是外网的ip，就会在整个包裹上再打包一个以太网头。这个以太网头主要是自己主机的mac地址和当前局域网网关的mac地址。
- 物理层拿到数据后，转为二进制01数据，通过网络传输送到对方局域网的网关（这中间经过交互机、路由系统等），根据ip地址找到主机(arp协议)，再根据端口号找到软件，再根据url路径找到资源。
- 然后对方主机返回响应数据，按原路返回资源。我方接受到响应资源后就完成了一次网络通信。



这个过程涉及到打包和拆包的过程。发出去之前一层层打包，对方局域网收到包之后一层层拆包。其中，在打包的过程中，因为以太网数协议规定的一个帧最大是1500个字节，如果收到的上层包超多这个数值，则会把一个包分成多个帧分别发送。分的时候，每层协议的头部数据都不能动，因此分包分的实际是发送数据。当然了，在硬件支持能力支持的条件下，也可以吧1500字节这个限制点提高，这样就提高每个帧发出去的实际数据量。





## 网络快递协议

网络协议有很多，众多协议的目的都是为了信息高速公路上流量的有序转发。这个过程就类似实现生活中的快递服务，顶层的应用程序收发的数据就是快递包，快递任务不关心具体的任务包，而是要关心整个快递运输中需要执行的规范协议，只为保证快递包能顺利送达。





## Socket抽象层

网络协议众多写繁杂，应用程序的开发者想要开发程序就必须熟练掌握这些协议才能保证自己的程序可以正常收发数据包，可想而知，这个过程肯定的痛苦的。于是就有了 scoket抽象层，它把底层众多的网络协议封装抽象为接口，供上层应用程序调用，样做极大提高了开发效率。

几乎每种服务端语言都有一个socket抽象层的代码库供开发者使用，基于网络通信的应用程序基本上都是基于 socket 开发的，socket翻译过来是套接字，因此这类程序也称之为套接字程序。

![](socket.png)

### Python版本socket通信Demo

使用Python实现一个socket通信demo，演示 tcp的通信的简单流程

```python
# 服务端

import socket


phone = socket.socket(socket.AF_INET, socket.SOCK_STREAM)	
phone.bind(('127.0.0.1', 8080))	# 绑定ip/port
phone.listen(5)	# 监听，半连接池=5
while 1:		# 连接循环
    conn, addr = phone.accept()	# 等待结束客户端连接请求，获取连接和客户端ip/port
    while 1:
        try:	# 异常捕获是为了避免客户端突然断开连接造成的服务端奔溃，linux系统服务端此时会陷入死循环
            data = conn.recv(1024)	# 每次接收1024个字节
            print(data.decode('utf-8'))	
            conn.send(data.upper())
        except Exception as e:
            print(e)
            break

    conn.close()	# 通信结束，关闭连接
```

因为tcp是基于连接通信的，连接是双方的。一旦客户端单方面终端连接，服务端拿到的那个conn就是无效的了。此时服务端就会出现问题。windows系统上，就会报错。在linux系统上服务端就会陷入死循环，不停收空消息。解决办法是：windows上做一个异常捕获，捕获后中断通信循环。linux上判断收到的消息是否是空，空的话就跳出通信循环。

```python
# 客户端

import socket

phone = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
phone.connect(('127.0.0.1', 8080))	# 直接发起连请求，需要指代服务端的ip/port
while 1:
    haha = input('>>>:').strip()
    if haha == 'q':
        break
    if not haha:	# 防止客户端发空消息
        continue
    phone.send(haha.encode('utf-8'))	# 网络传输都是bytes二进制数据
    data = phone.recv(1024)				# 接收1024个字节
    print(data.decode('utf-8'))

phone.close()	# 通信结束关闭连接
```





## 子网划分

通过子网掩码长短的控制，将ip地址分散到不同的网段内。比如长度为24的子网掩码，256个ip在一个网络内，当子网掩码长度变成25，则256个ip分在了2个网络内（0-128在一个网络内，129-255在另一个网络内）。**<u>通过子网划分可以控制一个网络内可供是用的IP地址，即控制一个网络内主机的数量</u>**。



IP层面把网络划分为多个，但是在以太网层面，接在同一个交换机上的多个机器依然可以收发到广播消息，这显然不符合子网划分的初衷。为了解决这个问题，<u>**可以使用 vlan 技术，在一个交换机上划分多个虚拟局域网**</u>。这样操作后，子网划分后分在不同网络内的主机就不会再收到另一个网络发出的广播包了。



