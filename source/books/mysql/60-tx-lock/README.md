# 事务和锁



## 事务

事务（Transaction）是数据库操作的一个基本单元，它由一个或多个 SQL 语句组成。事务的核心思想是：**这些 SQL 语句要么全部成功执行，要么全部不执行**。



#### 事务的四大特性

事务必须满足四个特性，简称 ACID：

| 特性            | 全称       | 解释                                                         |
| :-------------- | :--------- | :----------------------------------------------------------- |
| **A**tomicity   | **原子性** | 事务是一个不可分割的工作单位。事务中的所有操作要么都发生，要么都不发生。 |
| **C**onsistency | **一致性** | 事务执行前后，数据库必须从一个一致性状态变换到另一个一致性状态。例如转账前后，两个账户的总金额保持不变。 |
| **I**solation   | **隔离性** | 数据库允许多个并发事务同时对其数据进行读写和修改的能力。隔离性可以防止多个事务并发执行时，由于交叉执行而导致数据的不一致。 |
| **D**urability  | **持久性** | 事务一旦被提交，它对数据库中数据的改变就是永久性的，即使系统发生故障也不会丢失。 |



## MySQL 事务运行模式

MySQL 默认使用的是 `InnoDB` 存储引擎，它才支持事务。`MyISAM` 引擎不支持事务。



#### 隐式开启隐式提交（默认）

MySQL 默认开启了自动提交模式。这意味着每一条单独的 SQL 语句都会被当作一个事务，并自动提交。

查看当前自动提交状态

~~~sql
SHOW VARIABLES LIKE 'autocommit'; 	-- 通常是 ON
~~~



#### 隐式开启显式提交

这种模式无需手动开启事务，执行一条 SQL 语句机会自动开启事务。然后需要手动使用提交事务。手动使用 `commit;` 或者 `rollback;` 结束事务。

想要使用这种模式，需要关闭自动提交。

临时关闭自动提交

~~~sql
SET autocommit = 0;
-- 开启自动提交
SET autocommit = 1;
~~~

永久关闭

~~~bash
# /etc/my.cnf
[mysqld]
autocommit=0
~~~



#### 显式开启显式提交

手动使用 `begin;` 或者 `start transaction;` 开启事务。然后执行 SQL 语句，直到使用 `commit;` 或折`rollback;` 结束事务。

手动开启的事务，默认不会自动提交。



## 事务保存点

在一个大事务中，你可以设置保存点，以便回滚到事务内的特定点，而不是回滚整个事务。

```sql
START TRANSACTION;

UPDATE account SET balance = balance - 100 WHERE id = 1;
SAVEPOINT point_a; -- 设置一个保存点 point_a

UPDATE account SET balance = balance + 100 WHERE id = 2;
-- 假设这里发生了某种错误，但我们只想回滚到 point_a
ROLLBACK TO SAVEPOINT point_a;

-- 此时，第二个 UPDATE 被撤销，第一个 UPDATE 仍然有效
-- 可以继续执行其他操作，然后提交或回滚整个事务
COMMIT;
```



## 事务中的 undo 和 redo

**事务四大特性中的一致性和持久性由事务中的 undo 日志和 redo 日志保证。**



#### Undo log

undo log 用于回滚操作。在修改语句修改 buffer pool 中的数据前，把旧值保存在 undo log 中。当事务错误执行回滚操作时使用 undo log 来恢复旧值。

undolog分两种类型，分别是 insert undo log 和 update undo log。

- insert undo log 是插入数据时产生的。因为插入行为只对本事务可见，对其他事务不可见。故在事务提交后可以直接删除。但是清理并不是在事务提交的“瞬间”同步进行的，而是通过一个异步的清理线程。
- Update undo log 是 update 和 delete 操作产生的。该 undo log 可能想要提供 MVCC 机制，因此不能在事务提交时就删除。



#### Redo log

Redo log 记录的是修改后的新值。在事务 commit 前未把数据刷到硬盘，如果遇到宕机，MySQL 会使用 bin log 和 redo log 完成故障修复。

这其中会发生两阶段提交，目的就是为了保证数据安全。让 bin log 种记录的修改行为和 redo log 中记录的修改值相匹配。可以使用参数 `innodb_flush_log_at_trx_commit` 控制 redo log 的刷盘策略。使用参数 `sync_binlog` 控制 bin log 的刷盘策略。默认推荐这两个值都为 1。



## 读现象

在高并发场景下，多个事务并发执行时，如果没有任何处理机制，大概率会出现不合理的读现象。这些现象包括：脏读、不可重复读、幻读。

MySQL 准备了多种锁机制和隔离级别来避免上述读现象的发生。

#### 脏读

一个事务读到了另一个未提交事务修改的数据。如果那个事务回滚了，那么读到的数据就是“脏”的、无效的。

#### 不可重复读

在同一个事务中，多次读取同一数据，得到的结果不同。这是因为在读取间隙，该数据被另一个已提交事务修改了。

#### 幻读

幻读是不可重复读的一个特殊场景。具体指的是范围读数据时，范围内出现了其他事务更新或插入的数据。



## 事务的隔离级别

MySQL 的四种隔离级别（从宽松到严格）

| 隔离级别                        | 脏读   | 不可重复读 | 幻读   | 备注                                                         |
| :------------------------------ | :----- | :--------- | :----- | :----------------------------------------------------------- |
| READ UNCOMMITTED（读未提交 RU） | ❌ 可能 | ❌ 可能     | ❌ 可能 | 性能最好，但问题最多，很少使用。                             |
| READ COMMITTED（读已提交 RC）   | ✅ 避免 | ❌ 可能     | ❌ 可能 | 只能读取已提交的数据。Oracle、SQL Server 默认级别。          |
| REPEATABLE READ（可重复读 RR）  | ✅ 避免 | ✅ 避免     | ❌ 可能 | **MySQL InnoDB 的默认级别**。通过 MVCC 机制在一定程度上也避免了幻读。 |
| SERIALIZABLE（串行化 S）        | ✅ 避免 | ✅ 避免     | ✅ 避免 | 通过强制事务串行执                                           |

查看和设置隔离级别

~~~sql
-- 查看当前会话的隔离级别
SELECT @@transaction_isolation;

-- 查看全局的隔离级别
SELECT @@global.transaction_isolation;

-- 设置当前会话的隔离级别
SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;

-- 设置全局的隔离级别（需要权限，重启后失效）
SET GLOBAL TRANSACTION ISOLATION LEVEL REPEATABLE READ;
~~~



## 锁

锁是为了并发时保护数据安全的一种机制，MySQL 支持复杂且强大的锁机制。

MySQL 的锁机制大致可以分为四个层次：类型、粒度、模式和使用方式。

#### 锁粒度

锁的粒度指的是锁定的数据范围大小。粒度越小，并发性越好，但锁管理开销越大；粒度越大，并发性越差，但开销越小。

**全局锁**。锁定整个数据库实例。使数据库处于只读状态。所有数据更新语句（DML）和数据结构修改语句（DDL）都会被阻塞。

加锁和解锁

~~~sql
-- 加锁
FLUSH TABLES WITH READ LOCK;
~~~

**表级锁**。锁定整张表。读锁之间不互斥，但写锁会阻塞其他所有读写操作。

~~~sql
-- 加锁
LOCK TABLES table_name READ/WRITE;
-- 解锁
UNLOCK TABLES;
~~~

**行级锁**。锁定某一行或行范围的数据。**InnoDB** 支持行级锁，这也是 InnoDB 取代 MyISAM 成为默认存储引擎的关键原因之一。



## InnoDB 的行级锁

InnoDB 中行锁在使用模式上可以分为两类：共享锁和互斥锁。

**共享锁的目的是为了读**。确保在读取数据时，数据不会被其他事务修改。多个事务可以同时获取同一数据行的共享锁（兼容），但不能有排他锁（互斥锁）。拿到共享锁的事务可以读数据，但写数据会被阻塞直到其他事务都释放了共享锁。

开启共享锁

~~~sql
select id, name from t1 where id=100 lock in share mode;
~~~

**互斥锁的目的是为了写。**确保在修改数据时，一个事务能进行修改。其他事务写会被阻塞，知道抢到锁的事务释放互斥锁。

`UPDATE`, `DELETE`, `INSERT` 语句会自动加互斥锁。读数据时也可以加互斥锁。

~~~sql
select id, name from t1 where id=100 for update;
~~~

<br>

#### 通过索引的方式锁数据

InnoDB 的行锁是基于索引实现的。如果一条 SQL 语句没有使用到索引，InnoDB 就不会使用行锁，而是退化为表锁。

**如果命中主键索引**。则通过主键索引树上的主键值把数据行锁住。

**如果命中辅助索引。**则先在辅助索引树上把索引值锁住，然后再拿着主键值到主键索引树上把数据行锁住。

有的时候使用索引锁住某行，但是发现相邻行可能也被锁住了。这是因为锁的算法发挥了作用。

<br>

#### 锁的算法

**记录锁**（Record Locks）。锁定索引中的一条具体记录。锁指定的索引行。

**间隙锁**（Gap Locks）。锁定一个索引**记录之间的范围**，但不包括记录本身。目的解决幻读问题。它阻止其他事务在间隙中插入新的记录。通常在 `REPEATABLE-READ` 隔离级别下，使用范围查询或查询不存在的记录时触发。

**临键锁**（Next-Key Locks）。它是 **记录锁 + 间隙锁** 的组合。锁定一个索引记录以及该记录之前的间隙。左开右闭区间，例如 `(5, 10]`。它是 InnoDB 在 `REPEATABLE-READ` 隔离级别下的默认行锁算法。

~~~sql
-- 示例：如果索引有值 10, 11, 13。执行 
SELECT * FROM t WHERE id > 11 FOR UPDATE;

-- 会锁住 13 这条记录（记录锁），以及 (11, 13) 这个间隙（间隙锁），以及 (13, +∞) 这个间隙。
-- 相当于锁定了 (11, +∞) 这个范围。
~~~





