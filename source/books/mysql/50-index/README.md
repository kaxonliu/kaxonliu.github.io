# 索引

索引是一种数据结构，是一种数据的组织方式。目的是为了加速数据的查询速度。

MySQL 支持多种索引类型，不同的存储引擎支持的索引类型不同。总的来说有三种主要索引类型，分别是 B+ 树索引、哈希索引、全文索引。其中， B+ 树索引加快等值查询和范围查询，哈希索引加速等值查询，全文索引适合长文本查询。

对于 `InnoDB` 储存引擎，主要支持用户使用 B+ 树索引和全文索引（虽然内部 Buffer Pool 使用哈希索引，但用户层无法使用）。但我们一般主要使用 B+ 树索引加速查询，全文本索引虽然可以加速长文本查询但准确度较低，一般会使用专门的工具做长文本模糊查询。



## B+ 树索引结构演化

MySQL InnoDB 的 B+ 树索引结构并非一蹴而就，而是为了解决一系列其他数据结构的缺陷而演化来的。

整个演化过程始终围绕着**如何最大限度地减少磁盘 I/O 的次数**和**如何高效支持常见数据库操作（特别是范围查询）** 这两个核心目标展开。



#### 基础

给某个字段创建索引，就是把这个字段的值做 KEY，然后以所有的 KEY 为基础构建索引树结构，树中的每个节点的 KEY 为 字段值，每个节点的 VALUE 值视情况而定（行数据或者主键值）。

<br>

#### 二叉树（Binary Search Tree）

每个节点最多有两个子节点（左子树和右子树），且左子节点的值 < 父节点的值 < 右子节点的值。理论上，查找、插入、删除的时间复杂度为 O(log n)，比遍历所有数据的 O(n) 快很多。

缺点：**极度依赖插入顺序**。如果插入的数据是有序的（如 1, 2, 3, 4, 5...），二叉树会退化成**链表**。此时查找效率变回 O(n)，完全失去了索引的意义。

~~~
        5
       /
      4
     /
    3
   /
  2
 /
1
~~~

<br>

#### 平衡二叉树 (AVL Tree)

为了解决二叉树退化成链表的问题，在二叉树的基础上，通过旋转操作确保任何节点的左右子树高度差绝对值不超过 1。这是一种严格平衡的二叉树。保证了树的平衡，最坏情况下查找效率也能稳定在 O(log n)，解决了二叉树的致命缺陷。

但是**每个节点只存储一个键值（Key）和数据（Data）**，这种结构导致树的高度会很高，对于海量数据，磁盘 I/O 的次数就会很多，查询速度急速下降，这对于海量数据是难以接受的。

平衡二叉树逻辑上是平衡的，但**在物理上（磁盘访问次数）效率不高**。我们需要一种“更矮更胖”的树。

>补充，比如存储 100 万条数据，树的高度可能接近 20。这意味着最坏情况下需要 20 次磁盘 I/O 才能找到目标数据。

<br>

#### B 树 (B-Tree)

解决平衡二叉树“太高”和“节点数据太少”的问题，减少磁盘 I/O，B 树**一个节点可以存储多个键值（Key）和对应的数据（Data）**（注意：这里的“数据”在索引中可能是行数据或主键值）。这极大地降低了树的高度，性能远超平衡二叉树。并且节点中的键值是有序的。

缺点：

- **节点中存储了“数据”（Data）**。如果“数据”是完整的行记录（对于聚簇索引），那么节点能存储的键值数量会变少，导致树高增加。
- **范围查询不够优化**。虽然比二叉树好，但进行范围查询时，仍然需要在内部节点和叶子节点之间来回穿梭和进行中序遍历。

<br>

####  B+ 树 (B+ Tree) - InnoDB 的最终选择

在 B 树的基础上进一步优化，相比于 B 树，它在主要在下面三个方面做了改进
1. 非叶子节点只存键（Key）和子节点指针，不存数据（Data）。
2. 所有数据（Data）都存储在叶子节点中。
3. 叶子节点之间通过双向指针串联成一个有序链表。



InnoDB 选择 B+ 树 有如下优点：
- **树更低 IO次数少**。因为非叶子节点不再存储数据，所以一个节点可以容纳更多的键（Key），从而使得树的阶数更大、高度更低，查询 I/O 次数更少，速度更快。
- **范围查询速度更快**。因为叶子节点之间使用双向链表连接，一旦在叶子节点上找到了范围的起始点，就可以沿着链表的指针顺序遍历，直到范围结束。这个过程几乎完全是顺序 I/O，效率极高。而 B 树节点之间没有连续，每次都需要从根节点做查询，会产生大量 I/O。
- **更好的缓存命中**。数据库可以将更高层的非叶子节点常驻在内存中。这样，绝大部分查询只需要一次磁盘 I/O（访问叶子节点）即可完成，极大地提升了性能。
- **全盘扫描更快**。只需要遍历叶子节点的链表即可得到全部数据，而不需要像 B 树那样对整棵树进行中序遍历。



## InnoDB 中 B+ 树的索引分类

主要分为两类，一类是主键索引，另一类是非主键索引。

**主键索引**，又称聚集索引、聚簇索引。每个叶子节点上存的 KEY 为主键值，VALUE 为行数据。每个表只有一个主键索引。如果没有主键，InnoDB 会选择一个唯一非空索引代替，如果没有这样的索引，则会隐式定义一个 rowid 作为主键索引。

**辅助索引**，又称二级索引、非聚簇索引。每个叶子节点上存的 KEY 为辅助索引值，VALUE 为主键值。当通过二级索引查询时，首先找到对应的主键，然后再回到聚簇索引（这个过程称为**回表**）去查找完整的数据行。一个表可以有多个辅助索引。

除此之外，还有唯一索引、联合主键索引、联合唯一索引、普通联合索引。

其中，主键索引和唯一索引除了具备索引加速能力，还有表字段约束能力。主键索引的约束是唯一且非空，唯一索引的约束是表字段值必须唯一。

联合类型的索引，就是把多个字段合成一个索引树，KEY 为多个字段值的合并。



## 回表和覆盖索引

查询条件使用辅助索引，如果查询值在辅助索引树上就可以找到，这就属于覆盖索引了，不需要在去主键索引树去查询其他数据。

如果在辅助索引树上找不到需要的查询值，那就需要拿着从辅助索引树上的找到的主键值，去主键索引树上查询需要的值数据。这个过程称之为回表。

概括如下：

- 查询条件使用主键索引，那么一定覆盖索引，没有回表操作一说。
- 查询条件使用辅助苏音，如果查询数据在辅助索引树上，那么覆盖索引且不需要回表。否则没有覆盖索引需要回表操作。





## 联合索引和最左前缀原则

#### 联合索引

联合索引是指一个索引包含多个列（通常是 2-3 个）。比如创建一个基于 `last_name`, `first_name`, `age` 三列的联合索引。InnoDB 会在内部为这个表创建一个 B+ 树，这个树的键（Key）就是 `(last_name, first_name, age)` 这个元组。数据会按照以下规则排序：

1. 首先按 `last_name` 排序。
2. 如果 `last_name` 相同，再按 `first_name` 排序。
3. 如果 `last_name` 和 `first_name` 都相同，最后按 `age` 排序。

#### 最左前缀匹配原则

最左前缀匹配原则（Leftmost Prefix Principle）是使用联合索引时必须遵循的规则。它指的是：查询条件必须从联合索引的最左边列开始，并且不能跳过中间的列，才能充分利用索引。顺序不限，查询优化器会优化顺序。

因为索引的排序规则是**先按第一列排序，第一列相同再按第二列排序，以此类推**。如果你跳过了第一列 `last_name`，直接以 `first_name` 作为条件，那么 `first_name` 在索引中是无序的（因为只有在 `last_name` 相同的情况下 `first_name` 才有序），数据库就无法对 `first_name` 使用高效的索引范围查找，只能进行全索引扫描，效率大打折扣。

#### 常见总结

| 场景                 | 示例查询 (索引: (A, B, C))   | 索引使用情况                                 |
| :------------------- | :--------------------------- | :------------------------------------------- |
| 完美使用             | `WHERE A=1 AND B=2 AND C=3`  | 使用所有三列。                               |
| 部分使用             | `WHERE A=1 AND B=2`          | 使用 A, B 列                                 |
| 部分使用             | `WHERE A=1`                  | 仅使用 A 列                                  |
| 部分使用(范围)       | `WHERE A>1 AND A<10 AND B=2` | A 列用范围，B 列用过滤（ICP）                |
| 失效（跳过开头）     | `WHERE B=2` 或 `WHERE C=3`   | **无法使用索引**                             |
| 部分使用（跳过中间） | `WHERE A=1 AND C=3`          | **仅使用 A 列**，C 列由 ICP 过滤             |
| 部分使用             | `A LIKE 'Smi%'`              | 仅使用 A 列                                  |
| 失效                 | `A LIKE '%ith'`              | 无法使用索引进行范围查找，只能进行全索引扫描 |

#### 实践建议
1. 设计联合索引时，将区分度最高（唯一值最多）的列放在最左边，这样能过滤掉最多的数据。
2. 频繁使用的列应尽量纳入索引，并考虑其在 `WHERE`, `ORDER BY`, `GROUP BY` 子句中的顺序。
3. 理解最左前缀原则，避免创建无效的索引（如已有 `(A, B)` 索引，再创建 `(A)` 索引就是冗余的）。
4. 善用 `EXPLAIN` 命令分析你的 SQL 是否正确使用了索引。



## 索引下推 (ICP)

MySQL 5.6 引入的索引下推（Index Condition Pushdown, ICP）优化了对未使用到的索引列的查询。ICP 将部分过滤工作从 Server 层“下推”到了存储引擎层，减少了回表的次数和返回给 Server 层的数据量，这大大提升了性能。

#### 示例1

比如：创建了联合索引（last_name，first_name，age），查询语句为 `WHERE last_name = 'Smith' AND age = 30`（跳过了 `first_name`）。

**没有ICP时**：

1. 存储引擎通过索引的 `last_name` 找到所有 `last_name = 'Smith'` 的记录。
2. 将这些记录对应的所有主键 ID 返回给 Server 层。
3. Server 层再根据这些 ID 回表读取完整行数据。
4. Server 层在行数据中过滤 `age = 30` 的条件。

**有ICP时**：

1. 存储引擎通过索引的 `last_name` 找到所有 `last_name = 'Smith'` 的记录。
2. **存储引擎会顺便检查这条索引记录中的 `age` 字段（即使它未被用于查找）是否满足 `age = 30`**。
3. 只有满足 `age = 30` 的索引记录，才会将其主键 ID 返回给 Server 层。
4. Server 层再回表取数据，这样减少了给 Server 的数据量并且减少回表的次数。



**注意**：索引下推（ICP）优化主要针对由 `AND` 连接的查询条件。对于由 `OR` 连接的查询条件，通常无法进行有效的索引下推。



#### 示例2

如果 last_name first_name age 三个字段没有创建联合索引，只把 last_name 创建了普通索引。查询条件为

~~~sql
age > 10 and first_name like 'prefix%' and last_name ='zhangsan'; 
~~~

此时，因为只有一个普通索引：idx_last_name (last_name)，即使可以使用 ICP，首先在辅助索引树上利用 last_name 做快速筛选。但是因为这个索引树上没有 first_name 和 age 的值，存储引擎无法过滤满足这两个字段的数据，只能将数据返回给 Server 并回表查询。**ICP优化器仍然会工作，只是下推的效果非常有限。**



## 管理索引

#### 创建表时直接创建索引

全部为单列索引的创建语法

~~~sql
create table t1(
    id int primary key,
    name varchar(20) unique,
    kid varchar(20),
    -- 为 kid 列创建一个名为 idx_kid 的普通索引
    index idx_kid (kid)
);
~~~

联合索引的创建语法

~~~sql
create table t1(
    id int,
    kid varchar(20),
    nickname varchar(20),
    first_name varchar(20),
    last_name varchar(20),
    age int,
    PRIMARY KEY (id),             
    UNIQUE INDEX unique_index_name (nickname), 
    INDEX index_name (last_name,first_name,age),   
    KEY key_name (age)         -- KEY 是 INDEX 的同义词
);

-- 括号内放一个字段就是单列索引，放两个字段就是联合索引。
-- primary key 不需要指定<索引名>
~~~



#### 后加索引

后加普通索引

~~~sql
ALTER TABLE products ADD INDEX idx_price (price);
-- 或
CREATE INDEX idx_price ON products (price);
~~~

后加唯一索引

~~~sql
ALTER TABLE t1 ADD UNIQUE INDEX idx_name (name);
-- 或
CREATE UNIQUE INDEX idx_name ON t1 (name);
~~~

加主键索引

~~~sql
-- 只能使用 alter
alter table t1 add primary key (id);
~~~



#### 删除索引

使用 `ALTER TABLE`（推荐）

```sql
-- 删除普通索引、唯一索引、全文索引等
ALTER TABLE table_name DROP INDEX index_name;

-- 删除主键索引（特殊语法）
ALTER TABLE table_name DROP PRIMARY KEY;
```

使用 `DROP INDEX`（仅删除非主键索引）

```sql
DROP INDEX index_name ON table_name;
```



#### 查看表索引

~~~sql
desc t1;
show create table t1;
show index from t1;
~~~



## 工具 explain

`EXPLAIN` 是 MySQL 的一个关键字，用于获取 MySQL 如何执行一条 SELECT 语句的详细信息，是一个用于分析和优化 SQL 查询性能的至关重要的工具。

使用方法非常简单，直接在你要分析的 `SELECT` 语句前加上 `EXPLAIN` 关键字即可。

explain 的输出是一个包含多列的表格，重点关注如下几个：

| 列名          | 描述                                                         |
| :------------ | :----------------------------------------------------------- |
| select_type   | 查询的类型，例如是简单查询（`SIMPLE`）、子查询（`SUBQUERY`）、派生表（`DERIVED`）还是联合查询（`UNION`）。 |
| type          | **极其重要的列！** 表示表的访问/连接类型。从好到坏常见的有：`system` > `const` > `eq_ref` > `ref` > `range` > `index` > `ALL`。应尽量避免 `ALL`（全表扫描）。 |
| possible_keys | MySQL **可能** 会使用哪些索引来查找该表中的行。如果为 `NULL`，则没有可用的索引。 |
| key           | MySQL **实际** 决定使用的索引。如果为 `NULL`，则没有使用索引。 |
| key_len       | 使用的索引的长度（字节数）。越短越好，通常意味着只使用了索引的一部分。 |
| ref           | 显示索引的哪一列被用来与 `key` 列指定的索引进行比较。        |
| rows          | **MySQL 预估** 为了找到所需的行而需要读取的行数。这是一个估算值，但值越小越好。 |
| filtered      | 表示存储引擎返回的数据在服务器层过滤后，剩余多少满足查询条件的百分比。值越大越好。 |
| Extra         | 包含不适合在其他列显示的额外信息。常见的重要值有：`Using index`（覆盖索引），`Using where`（服务器层进行了过滤），`Using temporary`（使用了临时表），`Using filesort`（需要额外排序）。 |



## 工具 explain analyze

MySQL 8.0.18 引入了 `EXPLAIN ANALYZE`，这是一个更强大的工具。它**会实际执行查询**，并提供更精确、更详细的执行信息，包括实际花费的时间、循环次数等。

~~~sql
mysql> explain analyze select * from t1 where id<100;
+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| EXPLAIN                                                                                                                                                                                                                  |
+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| -> Filter: (t1.id < 100)  (cost=13.1 rows=64) (actual time=0.0636..0.114 rows=64 loops=1)
    -> Index range scan on t1 using PRIMARY over (id < 100)  (cost=13.1 rows=64) (actual time=0.0602..0.0979 rows=64 loops=1)
 |
+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
1 row in set (0.00 sec)

~~~



